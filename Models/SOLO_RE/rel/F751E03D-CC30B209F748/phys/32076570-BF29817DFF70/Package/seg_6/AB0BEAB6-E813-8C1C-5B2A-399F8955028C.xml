<?xml version = '1.0' encoding = 'UTF-8'?>
<PackageOracle class="oracle.dbtools.crest.model.design.storage.oracle.PackageOracle" name="PKG_HOUSEKEEPING" directorySegmentName="seg_6" id="AB0BEAB6-E813-8C1C-5B2A-399F8955028C">
<sourceConnName>SOLO_Prod</sourceConnName>
<sourceObjSchema>CHTR</sourceObjSchema>
<sourceObjName>PKG_HOUSEKEEPING</sourceObjName>
<createdBy>jandrews1</createdBy>
<createdTime>2015-08-11 13:17:14 UTC</createdTime>
<ownerDesignName>SOLO_RE</ownerDesignName>
<owner>5AF9E3FC-7A76-C437-3E83-BF29D7EA2FC7</owner>
<source>CREATE OR REPLACE PACKAGE      CHTR.PKG_HOUSEKEEPING&lt;br/&gt;IS&lt;br/&gt;/****************************************************************************************************************&lt;br/&gt;||  Program Name    : PKG_HOUSEKEEPING&lt;br/&gt;||  Created By      : Cognizant&lt;br/&gt;||  Created Date    : 24-Nov-2014&lt;br/&gt;||  Subject Area    : Staging Purge Process&lt;br/&gt;||  Description     : This is for purging the Processed and Error records from the Staging tables on a&lt;br/&gt;||                    predetermined basis.&lt;br/&gt;||  Change log:&lt;br/&gt;||&lt;br/&gt;||  Changed By      Changed On      Change Description&lt;br/&gt;||  -------------------------------------------------------------------------------------------------------------&lt;br/&gt;||&lt;br/&gt;******************************************************************************************************************/&lt;br/&gt;&lt;br/&gt;PROCEDURE STG_PURGE_PROCESS&lt;br/&gt;    (&lt;br/&gt;       p_in_audit_user_i IN VARCHAR2&lt;br/&gt;    );&lt;br/&gt;END PKG_HOUSEKEEPING;</source>
<body class="oracle.dbtools.crest.model.design.storage.oracle.PackageBodyOracle" name="PKG_HOUSEKEEPING" id="AB0BEAB6-E813-8C1C-5B2A-399F8955028C">
<sourceConnName>SOLO_Prod</sourceConnName>
<sourceObjSchema>CHTR</sourceObjSchema>
<sourceObjName>PKG_HOUSEKEEPING</sourceObjName>
<createdBy>jandrews1</createdBy>
<createdTime>2015-08-11 13:17:15 UTC</createdTime>
<ownerDesignName>SOLO_RE</ownerDesignName>
<owner>5AF9E3FC-7A76-C437-3E83-BF29D7EA2FC7</owner>
<source>CREATE OR REPLACE PACKAGE BODY      CHTR.PKG_HOUSEKEEPING&lt;br/&gt;IS&lt;br/&gt;/****************************************************************************************************************&lt;br/&gt;||  Program Name    : PKG_HOUSEKEEPING&lt;br/&gt;||  Created By      : Cognizant&lt;br/&gt;||  Created Date    : 24-Nov-2014&lt;br/&gt;||  Subject Area    : Staging Purge Process&lt;br/&gt;||  Description     : This is for purging the Processed and Error records from the Staging tables on a&lt;br/&gt;||                    predetermined basis.&lt;br/&gt;||  Change log:&lt;br/&gt;||&lt;br/&gt;||  Changed By      Changed On      Change Description&lt;br/&gt;||  -------------------------------------------------------------------------------------------------------------&lt;br/&gt;||  1. Cognizant    Mar-17-2015     Introduced batchwise processing.&lt;br/&gt;||  2. Cognizant    Mar-18-2015     Moving Batchwise count to table level and Changeing input parameter for&lt;br/&gt;||                                  process&lt;br/&gt;||  3. Cognizant    Mar-20-2015     Due to ondemand purging, added new two columns&lt;br/&gt;||                                  record_stat_column and date_column&lt;br/&gt;||  4. Cognizant    Mar-30-2015     Due to recon purging, added new column process_mod_ind&lt;br/&gt;||  5. Cognizant    APR-03-2015     Due to recon purging, added new column process_mod_ind -- Removing DBMS_OUTPUT&lt;br/&gt;******************************************************************************************************************/&lt;br/&gt;   c_pkg_name   CONSTANT VARCHAR2 (30) := &apos;PKG_HOUSEKEEPING&apos;;&lt;br/&gt;   g_batchsize           NUMBER        := 1000000;&lt;br/&gt;&lt;br/&gt;   PROCEDURE stg_purge_process (p_in_audit_user_i IN VARCHAR2)&lt;br/&gt;   AS&lt;br/&gt;/****************************************************************************************************************&lt;br/&gt;||  Program Name       : STG_PURGE_PROCESS&lt;br/&gt;||  Estimated Run Time :&lt;br/&gt;||  Description        : This is for purging the Processed and Error records from the Staging tables on a&lt;br/&gt;||                       predetermined basis.&lt;br/&gt;******************************************************************************************************************/&lt;br/&gt;&lt;br/&gt;      --Constants and Variables&lt;br/&gt;      l_process_rec            pkg_logging.t_process_rec;&lt;br/&gt;      l_proc_name     CONSTANT VARCHAR2 (50)           := &apos;STG_PURGE_PROCESS&apos;;&lt;br/&gt;      l_purge_sql              VARCHAR2 (1000);&lt;br/&gt;      l_purge_interim_status   VARCHAR2 (100);&lt;br/&gt;      l_purge_record_cnt       NUMBER                    := 0;&lt;br/&gt;      exp_purge_error          EXCEPTION;&lt;br/&gt;&lt;br/&gt;      --Declaration of cursor and variables&lt;br/&gt;      CURSOR cur_purge_tbl_list&lt;br/&gt;      IS&lt;br/&gt;         SELECT table_name, retain_val_processd, retain_val_err,&lt;br/&gt;                NVL (batch_size, 10000) AS batch_size,&lt;br/&gt;                TRIM (date_column) AS date_column,&lt;br/&gt;                TRIM (record_stat_column) AS record_stat_column&lt;br/&gt;           FROM stg.stg_purge_ctrl&lt;br/&gt;          WHERE record_stat = pkg_utility.c_record_active&lt;br/&gt;            AND process_mod_ind = &apos;NRT&apos;;&lt;br/&gt;   BEGIN&lt;br/&gt;      --Initialisation of variables&lt;br/&gt;      l_process_rec.process_name := c_pkg_name;&lt;br/&gt;      -- g_batchsize                := p_batchsize;&lt;br/&gt;       --Inital Logging of process&lt;br/&gt;      pkg_logging.begin_process (l_process_rec,&lt;br/&gt;                                 &apos;p_audit_user_i=&apos; || p_in_audit_user_i&lt;br/&gt;                                );&lt;br/&gt;&lt;br/&gt;      --Looping through the Purge Table List&lt;br/&gt;      FOR cur_dtls IN cur_purge_tbl_list&lt;br/&gt;      LOOP&lt;br/&gt;         BEGIN&lt;br/&gt;            l_purge_record_cnt := 0;&lt;br/&gt;&lt;br/&gt;            --Checking whether the process has to be run or not now&lt;br/&gt;            IF pkg_utility.stopnow (c_pkg_name)&lt;br/&gt;            THEN&lt;br/&gt;               pkg_logging.end_process (l_process_rec,&lt;br/&gt;                                        pkg_utility.c_process_cancel&lt;br/&gt;                                       );&lt;br/&gt;               RETURN;&lt;br/&gt;            END IF;&lt;br/&gt;&lt;br/&gt;            LOOP&lt;br/&gt;               IF pkg_utility.stopnow (c_pkg_name)&lt;br/&gt;               THEN&lt;br/&gt;                  pkg_logging.end_process (l_process_rec,&lt;br/&gt;                                           pkg_utility.c_process_cancel&lt;br/&gt;                                          );&lt;br/&gt;                  RETURN;&lt;br/&gt;               END IF;&lt;br/&gt;&lt;br/&gt;/*--Formation of Purge script&lt;br/&gt;         l_purge_sql := &apos;DELETE FROM STG.&apos; || cur_dtls.table_name || &apos; WHERE ( (RECORD_LOAD_CD = &apos;&apos;&apos; ||&lt;br/&gt;                                pkg_utility.c_stg_processed || &apos;&apos;&apos; AND TRUNC(RECORD_DTTM) &lt; TRUNC(SYSDATE - &apos; || cur_dtls.retain_val_processd&lt;br/&gt;                                || &apos;)) OR &apos; || &apos;(RECORD_LOAD_CD = &apos;&apos;&apos; || pkg_utility.c_stg_error ||&lt;br/&gt;                                &apos;&apos;&apos; AND TRUNC(RECORD_DTTM) &lt; TRUNC(SYSDATE -&apos; || cur_dtls.retain_val_err || &apos;)))&apos;;*/&lt;br/&gt;&lt;br/&gt;               --Formation of Purge script&lt;br/&gt;               l_purge_sql :=&lt;br/&gt;                     &apos;DELETE FROM STG.&apos;&lt;br/&gt;                  || cur_dtls.table_name&lt;br/&gt;                  || &apos; WHERE ( ( &apos;&lt;br/&gt;                  || cur_dtls.record_stat_column&lt;br/&gt;                  || &apos;= &apos;&apos;&apos;&lt;br/&gt;                  || pkg_utility.c_stg_processed&lt;br/&gt;                  || &apos;&apos;&apos; AND TRUNC( &apos;&lt;br/&gt;                  || cur_dtls.date_column&lt;br/&gt;                  || &apos;) &lt; TRUNC(SYSDATE - &apos;&lt;br/&gt;                  || cur_dtls.retain_val_processd&lt;br/&gt;                  || &apos;)) OR &apos;&lt;br/&gt;                  || &apos;( &apos;&lt;br/&gt;                  || cur_dtls.record_stat_column&lt;br/&gt;                  || &apos;= &apos;&apos;&apos;&lt;br/&gt;                  || pkg_utility.c_stg_error&lt;br/&gt;                  || &apos;&apos;&apos; AND TRUNC( &apos;&lt;br/&gt;                  || cur_dtls.date_column&lt;br/&gt;                  || &apos;) &lt; TRUNC(SYSDATE -&apos;&lt;br/&gt;                  || cur_dtls.retain_val_err&lt;br/&gt;                  || &apos;)))&lt;br/&gt;                                AND ROWNUM &lt; &apos;&lt;br/&gt;                  || cur_dtls.batch_size;&lt;br/&gt;               --Logging for Debugging purposes&lt;br/&gt;               pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                                         l_proc_name&lt;br/&gt;                                      || &apos;, PURGE SQL : &apos;&lt;br/&gt;                                      || l_purge_sql&lt;br/&gt;                                     );&lt;br/&gt;&lt;br/&gt;               --Execution of the Purge script&lt;br/&gt;               EXECUTE IMMEDIATE (l_purge_sql);&lt;br/&gt;&lt;br/&gt;               EXIT WHEN SQL%ROWCOUNT = 0;&lt;br/&gt;               --Taking the total count of purged records&lt;br/&gt;               l_purge_record_cnt := l_purge_record_cnt + SQL%ROWCOUNT;&lt;br/&gt;               --Transaction Control on a single table level&lt;br/&gt;               COMMIT;&lt;br/&gt;            END LOOP;&lt;br/&gt;&lt;br/&gt;            IF l_purge_record_cnt &gt; 0&lt;br/&gt;            THEN&lt;br/&gt;               --Making entry to the Process Child table against totalPurge Count&lt;br/&gt;               pkg_logging.process_log_detail_populate&lt;br/&gt;                  (p_process_rec_i        =&gt; l_process_rec,&lt;br/&gt;                   p_audit_bucket_i       =&gt;    &apos;TOTAL NUMBER OF RECORDS PUREGED FROM TABLE &apos;&lt;br/&gt;                                             || cur_dtls.table_name,&lt;br/&gt;                   p_audit_value_i        =&gt; l_purge_record_cnt,&lt;br/&gt;                   p_process_id_i         =&gt; l_process_rec.process_id,&lt;br/&gt;                   p_in_audit_user_i      =&gt; p_in_audit_user_i&lt;br/&gt;                  );&lt;br/&gt;            END IF;&lt;br/&gt;         --Exception Handling&lt;br/&gt;         EXCEPTION&lt;br/&gt;            WHEN OTHERS&lt;br/&gt;            THEN&lt;br/&gt;               ROLLBACK;&lt;br/&gt;               l_purge_interim_status := pkg_utility.c_process_error;&lt;br/&gt;               pkg_logging.log_exception (l_process_rec,&lt;br/&gt;                                             l_proc_name&lt;br/&gt;                                          || &apos;, &apos;&lt;br/&gt;                                          || cur_dtls.table_name&lt;br/&gt;                                          || &apos;, exception=&apos;&lt;br/&gt;                                          || DBMS_UTILITY.format_error_stack&lt;br/&gt;                                                                           ()&lt;br/&gt;                                         );&lt;br/&gt;         END;&lt;br/&gt;      END LOOP;&lt;br/&gt;&lt;br/&gt;      --Marking the end of Purge process in Successful Status if the Purge process is success for whold the table list.&lt;br/&gt;      -- Otherwise marking in Error status&lt;br/&gt;      pkg_logging.end_process (l_process_rec,&lt;br/&gt;                               NVL (l_purge_interim_status,&lt;br/&gt;                                    pkg_utility.c_process_success&lt;br/&gt;                                   )&lt;br/&gt;                              );&lt;br/&gt;&lt;br/&gt;      --Checking whether all the STG tables are purged out successfull. If not, return the Error Status to the calling job&lt;br/&gt;      IF (l_purge_interim_status = pkg_utility.c_process_error)&lt;br/&gt;      THEN&lt;br/&gt;         RAISE exp_purge_error;&lt;br/&gt;      END IF;&lt;br/&gt;   --Exception Handling&lt;br/&gt;   EXCEPTION&lt;br/&gt;      WHEN exp_purge_error&lt;br/&gt;      THEN&lt;br/&gt;         --Return the Error Status to the calling job&lt;br/&gt;         RAISE;&lt;br/&gt;      WHEN OTHERS&lt;br/&gt;      THEN&lt;br/&gt;         --Rolling back the entire transaction for whole process&lt;br/&gt;         ROLLBACK;&lt;br/&gt;         --Exception Logging&lt;br/&gt;         pkg_logging.log_exception (l_process_rec,&lt;br/&gt;                                       l_proc_name&lt;br/&gt;                                    || &apos;, exception=&apos;&lt;br/&gt;                                    || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                                   );&lt;br/&gt;         --Marking the End of purge process in Error out status&lt;br/&gt;         pkg_logging.end_process (l_process_rec, pkg_utility.c_process_error);&lt;br/&gt;         --Return the Error Status to the calling job&lt;br/&gt;         RAISE;&lt;br/&gt;   END stg_purge_process;&lt;br/&gt;END pkg_housekeeping;</source>
</body>
</PackageOracle>
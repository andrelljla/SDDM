<?xml version = '1.0' encoding = 'UTF-8'?>
<PackageOracle class="oracle.dbtools.crest.model.design.storage.oracle.PackageOracle" name="PKG_VNT_RECON_PROCESS" directorySegmentName="seg_6" id="86F0D3EF-1D29-EFAB-FA6A-A4A17C03C1EA">
<sourceConnName>SOLO_Prod</sourceConnName>
<sourceObjSchema>CHTR</sourceObjSchema>
<sourceObjName>PKG_VNT_RECON_PROCESS</sourceObjName>
<createdBy>jandrews1</createdBy>
<createdTime>2015-08-11 13:20:04 UTC</createdTime>
<ownerDesignName>SOLO_RE</ownerDesignName>
<owner>5AF9E3FC-7A76-C437-3E83-BF29D7EA2FC7</owner>
<source>CREATE OR REPLACE PACKAGE      CHTR.PKG_VNT_RECON_PROCESS&lt;br/&gt;IS&lt;br/&gt;   /****************************************************************************************************************&lt;br/&gt;   ||  Program Name    : PKG_VNT_RECON_PROCES&lt;br/&gt;   ||  Created By        : Cognizant&lt;br/&gt;   ||  Created Date    : 12-Dec-2014&lt;br/&gt;   ||  Subject Area    : Reconciliation&lt;br/&gt;   ||  Description     : Wrapper package to hold the miscellanious jobs of  reconciliation.&lt;br/&gt;   ||                      : Includes Insert and Update procedure for stg.recon_Process_ctrl&lt;br/&gt;   ||                        Includes procedures for loading Recon key tables from NRT Stage tables.&lt;br/&gt;   ||                    : Procedure for populating the log table audit_recon_process.&lt;br/&gt;   ||&lt;br/&gt;   ||  Change log:&lt;br/&gt;   ||&lt;br/&gt;   ||    Changed By            Changed On               Change Description&lt;br/&gt;   ||  -------------------------------------------------------------------------------------------------------------&lt;br/&gt;&lt;br/&gt;   ******************************************************************************************************************/&lt;br/&gt;   --PROCEDURE LOAD(p_audit_user_i IN VARCHAR2);&lt;br/&gt;   PROCEDURE insert_recon_process_ctrl (p_recon_mode IN VARCHAR2,p_audit_user_i IN VARCHAR2);&lt;br/&gt;   PROCEDURE load_recon_sbb_keys(p_audit_user_i IN VARCHAR2);&lt;br/&gt;   PROCEDURE audit_recon_process_populate (&lt;br/&gt;      p_process_rec_i    IN   pkg_logging.t_process_rec,&lt;br/&gt;      p_table_name       IN   VARCHAR2,&lt;br/&gt;      p_table_key        IN   VARCHAR2,&lt;br/&gt;      p_modif_values     IN   VARCHAR2,&lt;br/&gt;      p_account_details      IN   VARCHAR2,&lt;br/&gt;      p_operation_perf   IN   VARCHAR2,&lt;br/&gt;      p_audit_user_i     IN   VARCHAR2&lt;br/&gt;   );&lt;br/&gt;&lt;br/&gt;   FUNCTION get_last_recon_date (&lt;br/&gt;      p_process_rec_i   IN       pkg_logging.t_process_rec,&lt;br/&gt;      p_audit_user_i IN VARCHAR2,&lt;br/&gt;      p_last_recon_date      OUT  DATE&lt;br/&gt;   )&lt;br/&gt;      RETURN BOOLEAN;&lt;br/&gt;         FUNCTION get_curr_recon_date (&lt;br/&gt;      p_process_rec_i   IN       pkg_logging.t_process_rec,&lt;br/&gt;      p_audit_user_i IN VARCHAR2,&lt;br/&gt;      p_curr_recon_date      OUT  DATE&lt;br/&gt;   )&lt;br/&gt;      RETURN BOOLEAN;&lt;br/&gt;   PROCEDURE update_recon_process_ctrl (p_recon_mode IN VARCHAR2,p_audit_user_i IN VARCHAR2);&lt;br/&gt;   PROCEDURE load_recon_keys_all(p_audit_user_i IN VARCHAR2);&lt;br/&gt;   PROCEDURE load_recon_oci_keys(p_audit_user_i IN VARCHAR2);&lt;br/&gt;   PROCEDURE load_recon_ord_keys(p_audit_user_i IN VARCHAR2);&lt;br/&gt;   PROCEDURE load_recon_ojb_keys(p_audit_user_i IN VARCHAR2);&lt;br/&gt;   PROCEDURE load_recon_otr_keys(p_audit_user_i IN VARCHAR2);&lt;br/&gt;   PROCEDURE update_recon_key_tables (p_recon_mode VARCHAR2,p_audit_user_i IN VARCHAR2);&lt;br/&gt;END pkg_vnt_recon_process;</source>
<body class="oracle.dbtools.crest.model.design.storage.oracle.PackageBodyOracle" name="PKG_VNT_RECON_PROCESS" id="86F0D3EF-1D29-EFAB-FA6A-A4A17C03C1EA">
<sourceConnName>SOLO_Prod</sourceConnName>
<sourceObjSchema>CHTR</sourceObjSchema>
<sourceObjName>PKG_VNT_RECON_PROCESS</sourceObjName>
<createdBy>jandrews1</createdBy>
<createdTime>2015-08-11 13:20:07 UTC</createdTime>
<ownerDesignName>SOLO_RE</ownerDesignName>
<owner>5AF9E3FC-7A76-C437-3E83-BF29D7EA2FC7</owner>
<source>CREATE OR REPLACE PACKAGE BODY      CHTR.PKG_VNT_RECON_PROCESS&lt;br/&gt;IS&lt;br/&gt;/****************************************************************************************************************&lt;br/&gt;||  Program Name    : PKG_VNT_RECON_PROCES&lt;br/&gt;||  Created By      : Cognizant&lt;br/&gt;||  Created Date    : 12-Dec-2014&lt;br/&gt;||  Subject Area    : Reconciliation&lt;br/&gt;||  Description     : Wrapper package to hold the miscellanious jobs of  reconciliation.&lt;br/&gt;||                  : Includes Insert and Update procedure for stg.recon_Process_ctrl&lt;br/&gt;||                    Includes procedures for loading Recon key tables from NRT Stage tables.&lt;br/&gt;||                  : Procedure for populating the log table audit_recon_process.&lt;br/&gt;||&lt;br/&gt;||  Change log:&lt;br/&gt;||&lt;br/&gt;||  Changed By           Changed On               Change Description&lt;br/&gt;||  Cognizant            03/05/2015               SIT DEFECT 36 (Having NULL in STOP_DTTM for the&lt;br/&gt;||                                                PKG_VNT_RECON_PROCESS package) SEARCH TAG  (DEF-36)&lt;br/&gt;||  Cognizant            20-Mar-2015              As part of Solo - Recon Post Prod Issues&lt;br/&gt;||  Cognizant            29-Apr-2015              Change in exception population&lt;br/&gt;||  Cognizant            14-May-2015              Removed the Update of recon_process_ctrl from I to P&lt;br/&gt;                                                  from UPDATE_RECON_KEY_TABLES PROC&lt;br/&gt;******************************************************************************************************************/&lt;br/&gt;   c_pkg_name     CONSTANT VARCHAR2 (55) := &apos;PKG_VNT_RECON_PROCESS&apos;;&lt;br/&gt;   l_last_run_recon_time   TIMESTAMP;&lt;br/&gt;&lt;br/&gt;   SUBTYPE t_unit_name IS VARCHAR2 (30);&lt;br/&gt;&lt;br/&gt;   exp_recon_status_ctrl   EXCEPTION;&lt;br/&gt;&lt;br/&gt;   FUNCTION get_last_recon_date (&lt;br/&gt;      p_process_rec_i     IN       pkg_logging.t_process_rec,&lt;br/&gt;      p_audit_user_i      IN       VARCHAR2,&lt;br/&gt;      p_last_recon_date   OUT      DATE&lt;br/&gt;   )&lt;br/&gt;      RETURN BOOLEAN&lt;br/&gt;/****************************************************************************************************************&lt;br/&gt;||  SubProgram Name    : GET_LAST_RECON_DATE&lt;br/&gt;||  Estimated Run Time :&lt;br/&gt;||  Description        : This is for getting the last reconciliation date&lt;br/&gt;*****************************************************************************************************************/&lt;br/&gt;   IS&lt;br/&gt;      l_proc_name       t_unit_name                  := &apos;GET_LAST_RECON_DATE&apos;;&lt;br/&gt;      l_process_name    t_process_log.process_name%TYPE         := c_pkg_name;&lt;br/&gt;      l_process_rec     pkg_logging.t_process_rec;&lt;br/&gt;      l_systimestamp    TIMESTAMP;&lt;br/&gt;      l_last_recon_dt   stg.recon_process_ctrl.recon_date%TYPE;&lt;br/&gt;      l_cur_recon_dt    stg.recon_process_ctrl.recon_date%TYPE;&lt;br/&gt;   BEGIN&lt;br/&gt;      l_process_rec.process_name := l_process_name;&lt;br/&gt;      l_systimestamp := SYSTIMESTAMP;&lt;br/&gt;      pkg_logging.begin_process (l_process_rec,&lt;br/&gt;                                 &apos;p_audit_user_i=&apos; || p_audit_user_i&lt;br/&gt;                                );&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos;&lt;br/&gt;                             || pkg_utility.c_proc_start_text&lt;br/&gt;                            );&lt;br/&gt;&lt;br/&gt;      SELECT NVL (MAX (recon_date), pkg_utility.c_recon_null_date)&lt;br/&gt;        INTO l_last_recon_dt&lt;br/&gt;        FROM stg.recon_process_ctrl&lt;br/&gt;       WHERE record_stat = pkg_utility.c_stg_processed&lt;br/&gt;         AND recon_mode = pkg_utility.c_recon_mode_dly;&lt;br/&gt;&lt;br/&gt;      p_last_recon_date := l_last_recon_dt;&lt;br/&gt;      pkg_logging.end_process (l_process_rec, pkg_utility.c_process_success);&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos; || pkg_utility.c_proc_end_text&lt;br/&gt;                            );&lt;br/&gt;      RETURN TRUE;&lt;br/&gt;   EXCEPTION&lt;br/&gt;      WHEN OTHERS&lt;br/&gt;      THEN&lt;br/&gt;         ROLLBACK;&lt;br/&gt;         pkg_logging.log_exception (l_process_rec,&lt;br/&gt;                                       l_proc_name&lt;br/&gt;                                    || &apos;, exception=&apos;&lt;br/&gt;                                    || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                                   );&lt;br/&gt;         pkg_logging.end_process (l_process_rec, pkg_utility.c_process_error);&lt;br/&gt;         pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                                   l_proc_name&lt;br/&gt;                                || &apos;ERROR IN FETCHING LAST RECON DATE &apos;&lt;br/&gt;                                || pkg_utility.c_process_error&lt;br/&gt;                               );&lt;br/&gt;   END get_last_recon_date;&lt;br/&gt;&lt;br/&gt;   FUNCTION get_curr_recon_date (&lt;br/&gt;      p_process_rec_i     IN       pkg_logging.t_process_rec,&lt;br/&gt;      p_audit_user_i      IN       VARCHAR2,&lt;br/&gt;      p_curr_recon_date   OUT      DATE&lt;br/&gt;   )&lt;br/&gt;      RETURN BOOLEAN&lt;br/&gt;/****************************************************************************************************************&lt;br/&gt;||  SubProgram Name    : GET_CURR_RECON_DATE&lt;br/&gt;||  Estimated Run Time :&lt;br/&gt;||  Description        : This is for getting the last reconciliation date&lt;br/&gt;******************************************************************************************************************/&lt;br/&gt;   IS&lt;br/&gt;      l_proc_name       t_unit_name                  := &apos;GET_CURR_RECON_DATE&apos;;&lt;br/&gt;      l_process_name    t_process_log.process_name%TYPE         := c_pkg_name;&lt;br/&gt;      l_process_rec     pkg_logging.t_process_rec;&lt;br/&gt;      l_systimestamp    TIMESTAMP;&lt;br/&gt;      l_last_recon_dt   stg.recon_process_ctrl.recon_date%TYPE;&lt;br/&gt;      l_cur_recon_dt    stg.recon_process_ctrl.recon_date%TYPE;&lt;br/&gt;   BEGIN&lt;br/&gt;      l_process_rec.process_name := l_process_name;&lt;br/&gt;      l_systimestamp := SYSTIMESTAMP;&lt;br/&gt;      pkg_logging.begin_process (l_process_rec,&lt;br/&gt;                                 &apos;p_audit_user_i=&apos; || p_audit_user_i&lt;br/&gt;                                );&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos;&lt;br/&gt;                             || pkg_utility.c_proc_start_text&lt;br/&gt;                            );&lt;br/&gt;&lt;br/&gt;      SELECT recon_date&lt;br/&gt;        INTO l_cur_recon_dt&lt;br/&gt;        FROM stg.recon_process_ctrl&lt;br/&gt;       WHERE record_stat = pkg_utility.c_stg_in_progress&lt;br/&gt;         AND recon_mode = pkg_utility.c_recon_mode_dly;&lt;br/&gt;&lt;br/&gt;      p_curr_recon_date := l_cur_recon_dt;&lt;br/&gt;      pkg_logging.end_process (l_process_rec, pkg_utility.c_process_success);&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos; || pkg_utility.c_proc_end_text&lt;br/&gt;                            );&lt;br/&gt;      RETURN TRUE;&lt;br/&gt;   EXCEPTION&lt;br/&gt;      WHEN OTHERS&lt;br/&gt;      THEN&lt;br/&gt;         ROLLBACK;&lt;br/&gt;         pkg_logging.log_exception (l_process_rec,&lt;br/&gt;                                       l_proc_name&lt;br/&gt;                                    || &apos;, EXCEPTION = &apos;&lt;br/&gt;                                    || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                                   );&lt;br/&gt;         pkg_logging.end_process (l_process_rec, pkg_utility.c_process_error);&lt;br/&gt;         pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                                   l_proc_name&lt;br/&gt;                                || &apos; ERROR IN FETCHING CURRENT RECON DATE &apos;&lt;br/&gt;                               );&lt;br/&gt;         RAISE;&lt;br/&gt;   END get_curr_recon_date;&lt;br/&gt;&lt;br/&gt;   PROCEDURE load_recon_keys_all (p_audit_user_i IN VARCHAR2)&lt;br/&gt;   IS&lt;br/&gt;/****************************************************************************************************************&lt;br/&gt;||  SubProgram Name    : LOAD_RECON_KEYS_ALL&lt;br/&gt;||  Estimated Run Time :&lt;br/&gt;||  Description        : This is for loading OnDemand Reonciliation Key tables from the&lt;br/&gt;||                            Corresponding NRT/RRT tables for the latest reconciled business_date&lt;br/&gt;&lt;br/&gt;******************************************************************************************************************/&lt;br/&gt;      l_proc_name      t_unit_name                   := &apos;LOAD_RECON_KEYS_ALL&apos;;&lt;br/&gt;      l_process_name   t_process_log.process_name%TYPE   := c_pkg_name;&lt;br/&gt;      l_process_rec    pkg_logging.t_process_rec;&lt;br/&gt;      l_systimestamp   TIMESTAMP;&lt;br/&gt;   BEGIN&lt;br/&gt;      l_process_rec.process_name := l_process_name;&lt;br/&gt;      l_systimestamp := SYSTIMESTAMP;&lt;br/&gt;      pkg_logging.begin_process (l_process_rec,&lt;br/&gt;                                 &apos;p_audit_user_i=&apos; || p_audit_user_i&lt;br/&gt;                                );&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos;&lt;br/&gt;                             || pkg_utility.c_proc_start_text&lt;br/&gt;                            );&lt;br/&gt;&lt;br/&gt;      IF pkg_utility.stopnow (c_pkg_name)&lt;br/&gt;      THEN&lt;br/&gt;         RETURN;&lt;br/&gt;      END IF;&lt;br/&gt;&lt;br/&gt;      BEGIN&lt;br/&gt;         load_recon_oci_keys (p_audit_user_i);&lt;br/&gt;         load_recon_ojb_keys (p_audit_user_i);&lt;br/&gt;         load_recon_ord_keys (p_audit_user_i);&lt;br/&gt;         load_recon_otr_keys (p_audit_user_i);&lt;br/&gt;      EXCEPTION&lt;br/&gt;         WHEN OTHERS&lt;br/&gt;         THEN&lt;br/&gt;            NULL;&lt;br/&gt;      END;&lt;br/&gt;&lt;br/&gt;      pkg_logging.end_process (l_process_rec, pkg_utility.c_process_success);&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos; || pkg_utility.c_proc_end_text&lt;br/&gt;                            );&lt;br/&gt;   EXCEPTION&lt;br/&gt;      WHEN OTHERS&lt;br/&gt;      THEN&lt;br/&gt;         ROLLBACK;&lt;br/&gt;         pkg_logging.log_exception (l_process_rec,&lt;br/&gt;                                       l_proc_name&lt;br/&gt;                                    || &apos;, exception=&apos;&lt;br/&gt;                                    || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                                   );&lt;br/&gt;         pkg_logging.end_process (l_process_rec, pkg_utility.c_process_error);&lt;br/&gt;         pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                                   l_proc_name&lt;br/&gt;                                || &apos; &apos;&lt;br/&gt;                                || pkg_utility.c_process_error&lt;br/&gt;                               );&lt;br/&gt;         RAISE;&lt;br/&gt;   END load_recon_keys_all;&lt;br/&gt;&lt;br/&gt;   PROCEDURE load_recon_oci_keys (p_audit_user_i IN VARCHAR2)&lt;br/&gt;   IS&lt;br/&gt;/****************************************************************************************************************&lt;br/&gt;||  SubProgram Name    : LOAD_RECON_OCI_KEYS&lt;br/&gt;||  Estimated Run Time :&lt;br/&gt;||  Description        : This is for loading Reonciliation Key table for OCI_CUR_ITEM from&lt;br/&gt;||                       Corresponding RRT table VNT_RRT_OIT_ITEMS mofidied after&lt;br/&gt;||                       the latest reconciled business_date&lt;br/&gt;******************************************************************************************************************/&lt;br/&gt;      l_proc_name       t_unit_name                  := &apos;LOAD_RECON_OCI_KEYS&apos;;&lt;br/&gt;      l_process_name    t_process_log.process_name%TYPE         := c_pkg_name;&lt;br/&gt;      l_process_rec     pkg_logging.t_process_rec;&lt;br/&gt;      l_systimestamp    TIMESTAMP;&lt;br/&gt;      l_last_recon_dt   stg.recon_process_ctrl.recon_date%TYPE;&lt;br/&gt;      l_cur_recon_dt    stg.recon_process_ctrl.recon_date%TYPE;&lt;br/&gt;   BEGIN&lt;br/&gt;      l_process_rec.process_name := l_process_name;&lt;br/&gt;      l_systimestamp := SYSTIMESTAMP;&lt;br/&gt;      pkg_logging.begin_process (l_process_rec,&lt;br/&gt;                                 &apos;p_audit_user_i=&apos; || p_audit_user_i&lt;br/&gt;                                );&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos;&lt;br/&gt;                             || pkg_utility.c_proc_start_text&lt;br/&gt;                            );&lt;br/&gt;&lt;br/&gt;      IF pkg_utility.stopnow (c_pkg_name)&lt;br/&gt;      THEN&lt;br/&gt;         pkg_logging.end_process (l_process_rec,&lt;br/&gt;                                  pkg_utility.c_process_success&lt;br/&gt;                                 );&lt;br/&gt;         pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                                   l_proc_name&lt;br/&gt;                                || &apos; &apos;&lt;br/&gt;                                || pkg_utility.c_proc_end_text&lt;br/&gt;                               );&lt;br/&gt;         RETURN;&lt;br/&gt;      END IF;&lt;br/&gt;&lt;br/&gt;      BEGIN&lt;br/&gt;         IF     get_last_recon_date (l_process_rec,&lt;br/&gt;                                     p_audit_user_i,&lt;br/&gt;                                     l_last_recon_dt&lt;br/&gt;                                    )&lt;br/&gt;            AND get_curr_recon_date (l_process_rec,&lt;br/&gt;                                     p_audit_user_i,&lt;br/&gt;                                     l_cur_recon_dt&lt;br/&gt;                                    )&lt;br/&gt;         THEN&lt;br/&gt;            INSERT INTO stg.vnt_ond_rec_key_oci&lt;br/&gt;                        (serv_id_oci, order_no_oci, record_stat,&lt;br/&gt;                         created_dttm, modified_dttm, created_by,&lt;br/&gt;                         modified_by, recon_mode)&lt;br/&gt;               SELECT DISTINCT serv_id_roit, order_no_roit,&lt;br/&gt;                               pkg_utility.c_record_active, l_systimestamp,&lt;br/&gt;                               NULL, p_audit_user_i, NULL,&lt;br/&gt;                               pkg_utility.c_recon_mode_dly&lt;br/&gt;                          FROM stg.vnt_rrt_oit_items&lt;br/&gt;                         WHERE TRUNC (pull_dte_roit) &gt;&lt;br/&gt;                                                      TRUNC (l_last_recon_dt)&lt;br/&gt;                           AND TRUNC (pull_dte_roit) &lt;= TRUNC (l_cur_recon_dt)&lt;br/&gt;                           AND order_no_roit != pkg_utility.c_dummy_order_no&lt;br/&gt;                           AND pull_tme_slot_roit &lt;&gt; 1&lt;br/&gt;               UNION&lt;br/&gt;               SELECT DISTINCT serv_id_roit, order_no_roit,&lt;br/&gt;                               pkg_utility.c_record_active, l_systimestamp,&lt;br/&gt;                               NULL, p_audit_user_i, NULL,&lt;br/&gt;                               pkg_utility.c_recon_mode_dly&lt;br/&gt;                          FROM stg.vnt_rrt_oit_items&lt;br/&gt;                         WHERE TRUNC (pull_dte_roit) &gt;&lt;br/&gt;                                                   TRUNC (l_last_recon_dt - 1)&lt;br/&gt;                           AND TRUNC (pull_dte_roit) &lt;=&lt;br/&gt;                                                    TRUNC (l_cur_recon_dt - 1)&lt;br/&gt;                           AND order_no_roit != pkg_utility.c_dummy_order_no&lt;br/&gt;                           AND pull_tme_slot_roit = 1;&lt;br/&gt;&lt;br/&gt;            INSERT INTO stg.vnt_ond_rec_key_opi&lt;br/&gt;                        (serv_id_opi, order_no_opi, record_stat, created_dttm,&lt;br/&gt;                         modified_dttm, created_by, modified_by, recon_mode)&lt;br/&gt;               SELECT DISTINCT serv_id_roit, order_no_roit,&lt;br/&gt;                               pkg_utility.c_record_active, l_systimestamp,&lt;br/&gt;                               NULL, p_audit_user_i, NULL,&lt;br/&gt;                               pkg_utility.c_recon_mode_dly&lt;br/&gt;                          FROM stg.vnt_rrt_oit_items&lt;br/&gt;                         WHERE TRUNC (pull_dte_roit) &gt; TRUNC (l_last_recon_dt)&lt;br/&gt;                           AND TRUNC (pull_dte_roit) &lt;= TRUNC (l_cur_recon_dt)&lt;br/&gt;                           AND pull_tme_slot_roit &lt;&gt; 1&lt;br/&gt;               UNION&lt;br/&gt;               SELECT DISTINCT serv_id_roit, order_no_roit,&lt;br/&gt;                               pkg_utility.c_record_active, l_systimestamp,&lt;br/&gt;                               NULL, p_audit_user_i, NULL,&lt;br/&gt;                               pkg_utility.c_recon_mode_dly&lt;br/&gt;                          FROM stg.vnt_rrt_oit_items&lt;br/&gt;                         WHERE TRUNC (pull_dte_roit) &gt;&lt;br/&gt;                                                   TRUNC (l_last_recon_dt - 1)&lt;br/&gt;                           AND TRUNC (pull_dte_roit) &lt;=&lt;br/&gt;                                                    TRUNC (l_cur_recon_dt - 1)&lt;br/&gt;                           AND pull_tme_slot_roit = 1;&lt;br/&gt;         ELSE&lt;br/&gt;            RAISE exp_recon_status_ctrl;&lt;br/&gt;         END IF;&lt;br/&gt;&lt;br/&gt;         COMMIT;&lt;br/&gt;      EXCEPTION&lt;br/&gt;         WHEN OTHERS&lt;br/&gt;         THEN&lt;br/&gt;            ROLLBACK;&lt;br/&gt;            pkg_logging.log_exception (l_process_rec,&lt;br/&gt;                                          l_proc_name&lt;br/&gt;                                       || &apos;, EXCEPTION = &apos;&lt;br/&gt;                                       || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                                      );&lt;br/&gt;            pkg_logging.end_process (l_process_rec,&lt;br/&gt;                                     pkg_utility.c_process_error&lt;br/&gt;                                    );&lt;br/&gt;            pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                                      l_proc_name&lt;br/&gt;                                   || &apos; &apos;&lt;br/&gt;                                   || pkg_utility.c_process_error&lt;br/&gt;                                  );&lt;br/&gt;            RAISE;&lt;br/&gt;      END;&lt;br/&gt;&lt;br/&gt;      pkg_logging.end_process (l_process_rec, pkg_utility.c_process_success);&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos; || pkg_utility.c_proc_end_text&lt;br/&gt;                            );&lt;br/&gt;   EXCEPTION&lt;br/&gt;      WHEN OTHERS&lt;br/&gt;      THEN&lt;br/&gt;         ROLLBACK;&lt;br/&gt;         pkg_logging.log_exception (l_process_rec,&lt;br/&gt;                                       l_proc_name&lt;br/&gt;                                    || &apos;, EXCEPTION = &apos;&lt;br/&gt;                                    || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                                   );&lt;br/&gt;         pkg_logging.end_process (l_process_rec, pkg_utility.c_process_error);&lt;br/&gt;         pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                                   l_proc_name&lt;br/&gt;                                || &apos; &apos;&lt;br/&gt;                                || pkg_utility.c_process_error&lt;br/&gt;                               );&lt;br/&gt;         RAISE;&lt;br/&gt;   END load_recon_oci_keys;&lt;br/&gt;&lt;br/&gt;   PROCEDURE load_recon_ord_keys (p_audit_user_i IN VARCHAR2)&lt;br/&gt;   IS&lt;br/&gt;      /****************************************************************************************************************&lt;br/&gt;      ||  SubProgram Name    : LOAD_RECON_ORD_KEYS&lt;br/&gt;      ||  Estimated Run Time :&lt;br/&gt;      ||  Description        : This is for loading OnDemand Reonciliation Key table for OOR_ORDER_OPEN/OCR_ORDER_COMP&lt;br/&gt;      ||                       from Corresponding RRT table VNT_RRT_OCR_ORDER_COMP/VNT_RRT_OOR_ORDER_OPEN mofidied&lt;br/&gt;      ||                       after the latest reconciled business_date&lt;br/&gt;      ******************************************************************************************************************/&lt;br/&gt;      l_proc_name       t_unit_name                  := &apos;LOAD_RECON_ORD_KEYS&apos;;&lt;br/&gt;      l_process_name    t_process_log.process_name%TYPE         := c_pkg_name;&lt;br/&gt;      l_process_rec     pkg_logging.t_process_rec;&lt;br/&gt;      l_systimestamp    TIMESTAMP;&lt;br/&gt;      l_last_recon_dt   stg.recon_process_ctrl.recon_date%TYPE;&lt;br/&gt;      l_cur_recon_dt    stg.recon_process_ctrl.recon_date%TYPE;&lt;br/&gt;   BEGIN&lt;br/&gt;      l_process_rec.process_name := l_process_name;&lt;br/&gt;      l_systimestamp := SYSTIMESTAMP;&lt;br/&gt;      pkg_logging.begin_process (l_process_rec,&lt;br/&gt;                                 &apos;p_audit_user_i=&apos; || p_audit_user_i&lt;br/&gt;                                );&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos;&lt;br/&gt;                             || pkg_utility.c_proc_start_text&lt;br/&gt;                            );&lt;br/&gt;&lt;br/&gt;      IF pkg_utility.stopnow (c_pkg_name)&lt;br/&gt;      THEN&lt;br/&gt;         RETURN;&lt;br/&gt;      END IF;&lt;br/&gt;&lt;br/&gt;      BEGIN&lt;br/&gt;         IF     get_last_recon_date (l_process_rec,&lt;br/&gt;                                     p_audit_user_i,&lt;br/&gt;                                     l_last_recon_dt&lt;br/&gt;                                    )&lt;br/&gt;            AND get_curr_recon_date (l_process_rec,&lt;br/&gt;                                     p_audit_user_i,&lt;br/&gt;                                     l_cur_recon_dt&lt;br/&gt;                                    )&lt;br/&gt;         THEN&lt;br/&gt;            INSERT INTO stg.vnt_ond_rec_key_order&lt;br/&gt;                        (order_number, record_stat, created_dttm,&lt;br/&gt;                         modified_dttm, created_by, modified_by, recon_mode)&lt;br/&gt;               SELECT DISTINCT order_no_rocr, pkg_utility.c_record_active,&lt;br/&gt;                               l_systimestamp, NULL, p_audit_user_i, NULL,&lt;br/&gt;                               pkg_utility.c_recon_mode_dly&lt;br/&gt;                          FROM stg.vnt_rrt_ocr_order_comp&lt;br/&gt;                         WHERE TRUNC (pull_dte_rocr) &gt;&lt;br/&gt;                                                      TRUNC (l_last_recon_dt)&lt;br/&gt;                           AND TRUNC (pull_dte_rocr) &lt;= TRUNC (l_cur_recon_dt)&lt;br/&gt;                           AND pull_tme_slot_rocr &lt;&gt; 1&lt;br/&gt;               UNION&lt;br/&gt;               SELECT DISTINCT order_no_roor, pkg_utility.c_record_active,&lt;br/&gt;                               l_systimestamp, NULL, p_audit_user_i, NULL,&lt;br/&gt;                               pkg_utility.c_recon_mode_dly&lt;br/&gt;                          FROM stg.vnt_rrt_oor_order_open&lt;br/&gt;                         WHERE TRUNC (pull_dte_roor) &gt; TRUNC (l_last_recon_dt)&lt;br/&gt;                           AND TRUNC (pull_dte_roor) &lt;= TRUNC (l_cur_recon_dt)&lt;br/&gt;                           AND pull_tme_slot_roor &lt;&gt; 1&lt;br/&gt;               UNION&lt;br/&gt;               SELECT DISTINCT order_no_rocr, pkg_utility.c_record_active,&lt;br/&gt;                               l_systimestamp, NULL, p_audit_user_i, NULL,&lt;br/&gt;                               pkg_utility.c_recon_mode_dly&lt;br/&gt;                          FROM stg.vnt_rrt_ocr_order_comp&lt;br/&gt;                         WHERE TRUNC (pull_dte_rocr) &gt;&lt;br/&gt;                                                   TRUNC (l_last_recon_dt - 1)&lt;br/&gt;                           AND TRUNC (pull_dte_rocr) &lt;=&lt;br/&gt;                                                    TRUNC (l_cur_recon_dt - 1)&lt;br/&gt;                           AND pull_tme_slot_rocr = 1&lt;br/&gt;               UNION&lt;br/&gt;               SELECT DISTINCT order_no_roor, pkg_utility.c_record_active,&lt;br/&gt;                               l_systimestamp, NULL, p_audit_user_i, NULL,&lt;br/&gt;                               pkg_utility.c_recon_mode_dly&lt;br/&gt;                          FROM stg.vnt_rrt_oor_order_open&lt;br/&gt;                         WHERE TRUNC (pull_dte_roor) &gt;&lt;br/&gt;                                                   TRUNC (l_last_recon_dt - 1)&lt;br/&gt;                           AND TRUNC (pull_dte_roor) &lt;=&lt;br/&gt;                                                    TRUNC (l_cur_recon_dt - 1)&lt;br/&gt;                           AND pull_tme_slot_roor = 1;&lt;br/&gt;         END IF;&lt;br/&gt;&lt;br/&gt;         COMMIT;&lt;br/&gt;      EXCEPTION&lt;br/&gt;         WHEN OTHERS&lt;br/&gt;         THEN&lt;br/&gt;            ROLLBACK;&lt;br/&gt;            pkg_logging.log_exception (l_process_rec,&lt;br/&gt;                                          l_proc_name&lt;br/&gt;                                       || &apos;, EXCEPTION = &apos;&lt;br/&gt;                                       || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                                      );&lt;br/&gt;            pkg_logging.end_process (l_process_rec,&lt;br/&gt;                                     pkg_utility.c_process_error&lt;br/&gt;                                    );&lt;br/&gt;            pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                                      l_proc_name&lt;br/&gt;                                   || &apos; &apos;&lt;br/&gt;                                   || pkg_utility.c_process_error&lt;br/&gt;                                  );&lt;br/&gt;            RAISE;&lt;br/&gt;      END;&lt;br/&gt;&lt;br/&gt;      pkg_logging.end_process (l_process_rec, pkg_utility.c_process_success);&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos; || pkg_utility.c_proc_end_text&lt;br/&gt;                            );&lt;br/&gt;   EXCEPTION&lt;br/&gt;      WHEN OTHERS&lt;br/&gt;      THEN&lt;br/&gt;         ROLLBACK;&lt;br/&gt;         pkg_logging.log_exception (l_process_rec,&lt;br/&gt;                                       l_proc_name&lt;br/&gt;                                    || &apos;, exception=&apos;&lt;br/&gt;                                    || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                                   );&lt;br/&gt;         pkg_logging.end_process (l_process_rec, pkg_utility.c_process_error);&lt;br/&gt;         pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                                   l_proc_name&lt;br/&gt;                                || &apos; &apos;&lt;br/&gt;                                || pkg_utility.c_process_error&lt;br/&gt;                               );&lt;br/&gt;         RAISE;&lt;br/&gt;   END load_recon_ord_keys;&lt;br/&gt;&lt;br/&gt;   PROCEDURE load_recon_ojb_keys (p_audit_user_i IN VARCHAR2)&lt;br/&gt;   IS&lt;br/&gt;      /****************************************************************************************************************&lt;br/&gt;      ||  SubProgram Name    : LOAD_ONDEMAD_OJB_KEYS&lt;br/&gt;      ||  Estimated Run Time :&lt;br/&gt;      ||  Description        : This is for loading OnDemand Reonciliation Key table for OJB_JOBS from&lt;br/&gt;      ||                       Corresponding RRT table VNT_RRT_OJB_JOBS mofidied after  the latest reconciled&lt;br/&gt;      ||                       business_date&lt;br/&gt;      ******************************************************************************************************************/&lt;br/&gt;      l_proc_name       t_unit_name                  := &apos;LOAD_RECON_OJB_KEYS&apos;;&lt;br/&gt;      l_process_name    t_process_log.process_name%TYPE         := c_pkg_name;&lt;br/&gt;      l_process_rec     pkg_logging.t_process_rec;&lt;br/&gt;      l_systimestamp    TIMESTAMP;&lt;br/&gt;      l_last_recon_dt   stg.recon_process_ctrl.recon_date%TYPE;&lt;br/&gt;      l_cur_recon_dt    stg.recon_process_ctrl.recon_date%TYPE;&lt;br/&gt;   BEGIN&lt;br/&gt;      l_process_rec.process_name := l_process_name;&lt;br/&gt;      l_systimestamp := SYSTIMESTAMP;&lt;br/&gt;      pkg_logging.begin_process (l_process_rec,&lt;br/&gt;                                 &apos;p_audit_user_i=&apos; || p_audit_user_i&lt;br/&gt;                                );&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos;&lt;br/&gt;                             || pkg_utility.c_proc_start_text&lt;br/&gt;                            );&lt;br/&gt;&lt;br/&gt;      IF pkg_utility.stopnow (c_pkg_name)&lt;br/&gt;      THEN&lt;br/&gt;         RETURN;&lt;br/&gt;      END IF;&lt;br/&gt;&lt;br/&gt;      BEGIN&lt;br/&gt;         IF     get_last_recon_date (l_process_rec,&lt;br/&gt;                                     p_audit_user_i,&lt;br/&gt;                                     l_last_recon_dt&lt;br/&gt;                                    )&lt;br/&gt;            AND get_curr_recon_date (l_process_rec,&lt;br/&gt;                                     p_audit_user_i,&lt;br/&gt;                                     l_cur_recon_dt&lt;br/&gt;                                    )&lt;br/&gt;         THEN&lt;br/&gt;            INSERT INTO stg.vnt_ond_rec_key_ojb&lt;br/&gt;                        (order_no_ojb, job_no_ojb, recon_mode, record_stat,&lt;br/&gt;                         created_dttm, modified_dttm, created_by,&lt;br/&gt;                         modified_by)&lt;br/&gt;               SELECT DISTINCT order_no_rojb, job_no_rojb,&lt;br/&gt;                               pkg_utility.c_recon_mode_dly,&lt;br/&gt;                               pkg_utility.c_record_active, l_systimestamp,&lt;br/&gt;                               NULL, p_audit_user_i, NULL&lt;br/&gt;                          FROM stg.vnt_rrt_ojb_jobs&lt;br/&gt;                         WHERE TRUNC (pull_dte_rojb) &gt;&lt;br/&gt;                                                      TRUNC (l_last_recon_dt)&lt;br/&gt;                           AND TRUNC (pull_dte_rojb) &lt;= TRUNC (l_cur_recon_dt)&lt;br/&gt;                           AND pull_tme_slot_rojb &lt;&gt; 1&lt;br/&gt;               UNION&lt;br/&gt;               SELECT DISTINCT order_no_rojb, job_no_rojb,&lt;br/&gt;                               pkg_utility.c_recon_mode_dly,&lt;br/&gt;                               pkg_utility.c_record_active, l_systimestamp,&lt;br/&gt;                               NULL, p_audit_user_i, NULL&lt;br/&gt;                          FROM stg.vnt_rrt_ojb_jobs&lt;br/&gt;                         WHERE TRUNC (pull_dte_rojb) &gt;&lt;br/&gt;                                                   TRUNC (l_last_recon_dt - 1)&lt;br/&gt;                           AND TRUNC (pull_dte_rojb) &lt;=&lt;br/&gt;                                                    TRUNC (l_cur_recon_dt - 1)&lt;br/&gt;                           AND pull_tme_slot_rojb = 1;&lt;br/&gt;         END IF;&lt;br/&gt;&lt;br/&gt;         COMMIT;&lt;br/&gt;      EXCEPTION&lt;br/&gt;         WHEN OTHERS&lt;br/&gt;         THEN&lt;br/&gt;            ROLLBACK;&lt;br/&gt;            pkg_logging.log_exception (l_process_rec,&lt;br/&gt;                                          l_proc_name&lt;br/&gt;                                       || &apos;, EXCEPTION = &apos;&lt;br/&gt;                                       || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                                      );&lt;br/&gt;            pkg_logging.end_process (l_process_rec,&lt;br/&gt;                                     pkg_utility.c_process_error&lt;br/&gt;                                    );&lt;br/&gt;            pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                                      l_proc_name&lt;br/&gt;                                   || &apos; &apos;&lt;br/&gt;                                   || pkg_utility.c_process_error&lt;br/&gt;                                  );&lt;br/&gt;            RAISE;&lt;br/&gt;      END;&lt;br/&gt;&lt;br/&gt;      pkg_logging.end_process (l_process_rec, pkg_utility.c_process_success);&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos; || pkg_utility.c_proc_end_text&lt;br/&gt;                            );&lt;br/&gt;   EXCEPTION&lt;br/&gt;      WHEN OTHERS&lt;br/&gt;      THEN&lt;br/&gt;         ROLLBACK;&lt;br/&gt;         pkg_logging.log_exception (l_process_rec,&lt;br/&gt;                                       l_proc_name&lt;br/&gt;                                    || &apos;, exception=&apos;&lt;br/&gt;                                    || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                                   );&lt;br/&gt;         pkg_logging.end_process (l_process_rec, pkg_utility.c_process_error);&lt;br/&gt;         pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                                   l_proc_name&lt;br/&gt;                                || &apos; &apos;&lt;br/&gt;                                || pkg_utility.c_process_error&lt;br/&gt;                               );&lt;br/&gt;         RAISE;&lt;br/&gt;   END load_recon_ojb_keys;&lt;br/&gt;&lt;br/&gt;   PROCEDURE load_recon_sbb_keys (p_audit_user_i IN VARCHAR2)&lt;br/&gt;   IS&lt;br/&gt;      /****************************************************************************************************************&lt;br/&gt;      ||  SubProgram Name    : LOAD_RECON_SBB_KEYS&lt;br/&gt;      ||  Estimated Run Time :&lt;br/&gt;      ||  Description        : This is for loading OnDemand Reonciliation Key table for SBB_BASEfrom&lt;br/&gt;      ||                       Corresponding NRT table VNT_NRT_ACCT mofidied after  the latest&lt;br/&gt;                               reconciled business_date&lt;br/&gt;      ******************************************************************************************************************/&lt;br/&gt;      l_proc_name       t_unit_name                  := &apos;LOAD_RECON_SBB_KEYS&apos;;&lt;br/&gt;      l_process_name    t_process_log.process_name%TYPE         := c_pkg_name;&lt;br/&gt;      l_process_rec     pkg_logging.t_process_rec;&lt;br/&gt;      l_systimestamp    TIMESTAMP;&lt;br/&gt;      l_last_recon_dt   stg.recon_process_ctrl.recon_date%TYPE;&lt;br/&gt;      l_cur_recon_dt    stg.recon_process_ctrl.recon_date%TYPE;&lt;br/&gt;   BEGIN&lt;br/&gt;      l_process_rec.process_name := l_process_name;&lt;br/&gt;      l_systimestamp := SYSTIMESTAMP;&lt;br/&gt;      pkg_logging.begin_process (l_process_rec,&lt;br/&gt;                                 &apos;p_audit_user_i=&apos; || p_audit_user_i&lt;br/&gt;                                );&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos;&lt;br/&gt;                             || pkg_utility.c_proc_start_text&lt;br/&gt;                            );&lt;br/&gt;&lt;br/&gt;      IF pkg_utility.stopnow (c_pkg_name)&lt;br/&gt;      THEN&lt;br/&gt;         RETURN;&lt;br/&gt;      END IF;&lt;br/&gt;&lt;br/&gt;      BEGIN&lt;br/&gt;         IF     get_last_recon_date (l_process_rec,&lt;br/&gt;                                     p_audit_user_i,&lt;br/&gt;                                     l_last_recon_dt&lt;br/&gt;                                    )&lt;br/&gt;            AND get_curr_recon_date (l_process_rec,&lt;br/&gt;                                     p_audit_user_i,&lt;br/&gt;                                     l_cur_recon_dt&lt;br/&gt;                                    )&lt;br/&gt;         THEN&lt;br/&gt;            INSERT INTO stg.vnt_ond_rec_key_sbb&lt;br/&gt;                        (sub_acct_no_sbb, record_stat, created_dttm,&lt;br/&gt;                         modified_dttm, created_by, modified_by, recon_mode)&lt;br/&gt;               SELECT DISTINCT sub_acct_no_nacc, pkg_utility.c_record_active,&lt;br/&gt;                               l_systimestamp, NULL, p_audit_user_i, NULL,&lt;br/&gt;                               pkg_utility.c_recon_mode_dly&lt;br/&gt;                          FROM stg.vnt_nrt_acct&lt;br/&gt;                         WHERE TRUNC (pull_dte_nacc) &gt;&lt;br/&gt;                                                      TRUNC (l_last_recon_dt)&lt;br/&gt;                           AND TRUNC (pull_dte_nacc) &lt;= TRUNC (l_cur_recon_dt)&lt;br/&gt;                           AND pull_tme_slot_nacc &lt;&gt; 1&lt;br/&gt;               UNION&lt;br/&gt;               SELECT DISTINCT sub_acct_no_nacc, pkg_utility.c_record_active,&lt;br/&gt;                               l_systimestamp, NULL, p_audit_user_i, NULL,&lt;br/&gt;                               pkg_utility.c_recon_mode_dly&lt;br/&gt;                          FROM stg.vnt_nrt_acct&lt;br/&gt;                         WHERE TRUNC (pull_dte_nacc) &gt;&lt;br/&gt;                                                   TRUNC (l_last_recon_dt - 1)&lt;br/&gt;                           AND TRUNC (pull_dte_nacc) &lt;=&lt;br/&gt;                                                    TRUNC (l_cur_recon_dt - 1)&lt;br/&gt;                           AND pull_tme_slot_nacc = 1;&lt;br/&gt;         END IF;&lt;br/&gt;&lt;br/&gt;         COMMIT;&lt;br/&gt;      EXCEPTION&lt;br/&gt;         WHEN OTHERS&lt;br/&gt;         THEN&lt;br/&gt;            ROLLBACK;&lt;br/&gt;            pkg_logging.log_exception (l_process_rec,&lt;br/&gt;                                          l_proc_name&lt;br/&gt;                                       || &apos;, EXCEPTION = &apos;&lt;br/&gt;                                       || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                                      );&lt;br/&gt;            pkg_logging.end_process (l_process_rec,&lt;br/&gt;                                     pkg_utility.c_process_error&lt;br/&gt;                                    );&lt;br/&gt;            pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                                      l_proc_name&lt;br/&gt;                                   || &apos; &apos;&lt;br/&gt;                                   || pkg_utility.c_process_error&lt;br/&gt;                                  );&lt;br/&gt;            RAISE;&lt;br/&gt;      END;&lt;br/&gt;&lt;br/&gt;      pkg_logging.end_process (l_process_rec, pkg_utility.c_process_success);&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos; || pkg_utility.c_proc_end_text&lt;br/&gt;                            );&lt;br/&gt;   EXCEPTION&lt;br/&gt;      WHEN OTHERS&lt;br/&gt;      THEN&lt;br/&gt;         ROLLBACK;&lt;br/&gt;         pkg_logging.log_exception (l_process_rec,&lt;br/&gt;                                       l_proc_name&lt;br/&gt;                                    || &apos;, EXCEPTION = &apos;&lt;br/&gt;                                    || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                                   );&lt;br/&gt;         pkg_logging.end_process (l_process_rec, pkg_utility.c_process_error);&lt;br/&gt;         pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                                   l_proc_name&lt;br/&gt;                                || &apos; &apos;&lt;br/&gt;                                || pkg_utility.c_process_error&lt;br/&gt;                               );&lt;br/&gt;         RAISE;&lt;br/&gt;   END load_recon_sbb_keys;&lt;br/&gt;&lt;br/&gt;   PROCEDURE load_recon_otr_keys (p_audit_user_i IN VARCHAR2)&lt;br/&gt;   IS&lt;br/&gt;      /****************************************************************************************************************&lt;br/&gt;      ||  SubProgram Name    : LOAD_RECON_OTR_KEYS&lt;br/&gt;      ||  Estimated Run Time :&lt;br/&gt;      ||  Description        : This is for loading OnDemand Reonciliation Key table for OTR_TROUBLE_CALL&lt;br/&gt;      ||                            Corresponding RRT table VNT_RRT_OTR_TROUBLE_CALL mofidied after  the latest&lt;br/&gt;      ||                                    reconciled business_date&lt;br/&gt;      ******************************************************************************************************************/&lt;br/&gt;      l_proc_name       t_unit_name                  := &apos;LOAD_RECON_OTR_KEYS&apos;;&lt;br/&gt;      l_process_name    t_process_log.process_name%TYPE         := c_pkg_name;&lt;br/&gt;      l_process_rec     pkg_logging.t_process_rec;&lt;br/&gt;      l_systimestamp    TIMESTAMP;&lt;br/&gt;      l_last_recon_dt   stg.recon_process_ctrl.recon_date%TYPE;&lt;br/&gt;      l_cur_recon_dt    stg.recon_process_ctrl.recon_date%TYPE;&lt;br/&gt;   BEGIN&lt;br/&gt;      l_process_rec.process_name := l_process_name;&lt;br/&gt;      l_systimestamp := SYSTIMESTAMP;&lt;br/&gt;      pkg_logging.begin_process (l_process_rec,&lt;br/&gt;                                 &apos;p_audit_user_i=&apos; || p_audit_user_i&lt;br/&gt;                                );&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos;&lt;br/&gt;                             || pkg_utility.c_proc_start_text&lt;br/&gt;                            );&lt;br/&gt;&lt;br/&gt;      IF pkg_utility.stopnow (c_pkg_name)&lt;br/&gt;      THEN&lt;br/&gt;         RETURN;&lt;br/&gt;      END IF;&lt;br/&gt;&lt;br/&gt;      BEGIN&lt;br/&gt;         IF     get_last_recon_date (l_process_rec,&lt;br/&gt;                                     p_audit_user_i,&lt;br/&gt;                                     l_last_recon_dt&lt;br/&gt;                                    )&lt;br/&gt;            AND get_curr_recon_date (l_process_rec,&lt;br/&gt;                                     p_audit_user_i,&lt;br/&gt;                                     l_cur_recon_dt&lt;br/&gt;                                    )&lt;br/&gt;         THEN&lt;br/&gt;            INSERT INTO stg.vnt_ond_rec_key_otr&lt;br/&gt;                        (order_no_otr, recon_mode, record_stat, created_dttm,&lt;br/&gt;                         modified_dttm, created_by, modified_by)&lt;br/&gt;               SELECT DISTINCT order_no_rotr, pkg_utility.c_recon_mode_dly,&lt;br/&gt;                               pkg_utility.c_record_active, l_systimestamp,&lt;br/&gt;                               NULL, p_audit_user_i, NULL&lt;br/&gt;                          FROM stg.vnt_rrt_otr_trouble_call&lt;br/&gt;                         WHERE TRUNC (pull_dte_rotr) &gt;&lt;br/&gt;                                                      TRUNC (l_last_recon_dt)&lt;br/&gt;                           AND TRUNC (pull_dte_rotr) &lt;= TRUNC (l_cur_recon_dt)&lt;br/&gt;                           AND pull_tme_slot_rotr &lt;&gt; 1&lt;br/&gt;               UNION&lt;br/&gt;               SELECT DISTINCT order_no_rotr, pkg_utility.c_recon_mode_dly,&lt;br/&gt;                               pkg_utility.c_record_active, l_systimestamp,&lt;br/&gt;                               NULL, p_audit_user_i, NULL&lt;br/&gt;                          FROM stg.vnt_rrt_otr_trouble_call&lt;br/&gt;                         WHERE TRUNC (pull_dte_rotr) &gt;&lt;br/&gt;                                                   TRUNC (l_last_recon_dt - 1)&lt;br/&gt;                           AND TRUNC (pull_dte_rotr) &lt;=&lt;br/&gt;                                                    TRUNC (l_cur_recon_dt - 1)&lt;br/&gt;                           AND pull_tme_slot_rotr = 1;&lt;br/&gt;         END IF;&lt;br/&gt;&lt;br/&gt;         COMMIT;&lt;br/&gt;      EXCEPTION&lt;br/&gt;         WHEN OTHERS&lt;br/&gt;         THEN&lt;br/&gt;            ROLLBACK;&lt;br/&gt;            pkg_logging.log_exception (l_process_rec,&lt;br/&gt;                                          l_proc_name&lt;br/&gt;                                       || &apos;, EXCEPTION = &apos;&lt;br/&gt;                                       || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                                      );&lt;br/&gt;            pkg_logging.end_process (l_process_rec,&lt;br/&gt;                                     pkg_utility.c_process_error&lt;br/&gt;                                    );&lt;br/&gt;            pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                                      l_proc_name&lt;br/&gt;                                   || &apos; &apos;&lt;br/&gt;                                   || pkg_utility.c_process_error&lt;br/&gt;                                  );&lt;br/&gt;            RAISE;&lt;br/&gt;      END;&lt;br/&gt;&lt;br/&gt;      pkg_logging.end_process (l_process_rec, pkg_utility.c_process_success);&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos; || pkg_utility.c_proc_end_text&lt;br/&gt;                            );&lt;br/&gt;   EXCEPTION&lt;br/&gt;      WHEN OTHERS&lt;br/&gt;      THEN&lt;br/&gt;         ROLLBACK;&lt;br/&gt;         pkg_logging.log_exception (l_process_rec,&lt;br/&gt;                                       l_proc_name&lt;br/&gt;                                    || &apos;, EXCEPTION = &apos;&lt;br/&gt;                                    || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                                   );&lt;br/&gt;         pkg_logging.end_process (l_process_rec, pkg_utility.c_process_error);&lt;br/&gt;         pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                                   l_proc_name&lt;br/&gt;                                || &apos; &apos;&lt;br/&gt;                                || pkg_utility.c_process_error&lt;br/&gt;                               );&lt;br/&gt;         RAISE;&lt;br/&gt;   END load_recon_otr_keys;&lt;br/&gt;&lt;br/&gt;   PROCEDURE insert_recon_process_ctrl (&lt;br/&gt;      p_recon_mode     IN   VARCHAR2,&lt;br/&gt;      p_audit_user_i   IN   VARCHAR2&lt;br/&gt;   )&lt;br/&gt;   /****************************************************************************************************************&lt;br/&gt;   ||  SubProgram Name    : INSERT_RECON_PROCESS_CTRL&lt;br/&gt;   ||  Estimated Run Time :&lt;br/&gt;   ||  Description        : This is for loading the table STG.RECON_PROCESS_CTRL at the start of the Recociliation&lt;br/&gt;   ||                       process&lt;br/&gt;   ******************************************************************************************************************/&lt;br/&gt;   IS&lt;br/&gt;      l_proc_name      VARCHAR2 (30)           := &apos;INSERT_RECON_PROCESS_CTRL&apos;;&lt;br/&gt;      l_process_name   t_process_log.process_name%TYPE          := c_pkg_name;&lt;br/&gt;      l_process_rec    pkg_logging.t_process_rec;&lt;br/&gt;      l_systimestamp   TIMESTAMP;&lt;br/&gt;      l_recon_date     stg.recon_process_ctrl.recon_date%TYPE;&lt;br/&gt;      exp_old_recon    EXCEPTION;&lt;br/&gt;      exp_recon_run    EXCEPTION;&lt;br/&gt;      l_recon_run      NUMBER                                   := 0;&lt;br/&gt;   BEGIN&lt;br/&gt;      l_process_rec.process_name := l_process_name;&lt;br/&gt;      l_systimestamp := SYSTIMESTAMP;&lt;br/&gt;      pkg_logging.begin_process (l_process_rec,&lt;br/&gt;                                 &apos;P_AUDIT_USER_I = &apos; || p_audit_user_i&lt;br/&gt;                                );&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos;&lt;br/&gt;                             || pkg_utility.c_proc_start_text&lt;br/&gt;                            );&lt;br/&gt;&lt;br/&gt;      IF pkg_utility.stopnow (c_pkg_name)&lt;br/&gt;      THEN&lt;br/&gt;         RETURN;&lt;br/&gt;      END IF;&lt;br/&gt;&lt;br/&gt;      --Check if any in-progress records presnt and raise&lt;br/&gt;      SELECT COUNT (1)&lt;br/&gt;        INTO l_recon_run&lt;br/&gt;        FROM stg.recon_process_ctrl&lt;br/&gt;       WHERE record_stat = pkg_utility.c_stg_in_progress;&lt;br/&gt;&lt;br/&gt;      IF l_recon_run &gt; 0&lt;br/&gt;      THEN&lt;br/&gt;         RAISE exp_recon_run;&lt;br/&gt;      END IF;&lt;br/&gt;&lt;br/&gt;      --Get current  Recon Date from Vantage&lt;br/&gt;      SELECT MAX (TO_DATE (process_date, &apos;YYYY-MM-DD&apos;)) - 1&lt;br/&gt;        INTO l_recon_date&lt;br/&gt;        FROM stg.vnt_partition_status&lt;br/&gt;       WHERE process_type = &apos;UPDATE&apos;;&lt;br/&gt;&lt;br/&gt;      IF get_last_recon_date (l_process_rec,&lt;br/&gt;                              p_audit_user_i,&lt;br/&gt;                              l_last_run_recon_time&lt;br/&gt;                             )&lt;br/&gt;      THEN&lt;br/&gt;         IF (p_recon_mode = pkg_utility.c_recon_mode_dly)&lt;br/&gt;         THEN&lt;br/&gt;            IF (l_last_run_recon_time &gt;= l_recon_date)&lt;br/&gt;            THEN&lt;br/&gt;               RAISE exp_old_recon;&lt;br/&gt;            END IF;&lt;br/&gt;         END IF;&lt;br/&gt;      END IF;&lt;br/&gt;&lt;br/&gt;      INSERT INTO stg.recon_process_ctrl&lt;br/&gt;                  (recon_process_id, recon_start_dttm,&lt;br/&gt;                   recon_end_dttm, recon_date, record_stat,&lt;br/&gt;                   created_by, created_dttm, modified_by, modified_dttm,&lt;br/&gt;                   recon_mode&lt;br/&gt;                  )&lt;br/&gt;           VALUES (stg.s_audit_recon_process_id.NEXTVAL, l_systimestamp,&lt;br/&gt;                   NULL, l_recon_date, pkg_utility.c_stg_in_progress,&lt;br/&gt;                   p_audit_user_i, l_systimestamp, NULL, NULL,&lt;br/&gt;                   p_recon_mode&lt;br/&gt;                  );&lt;br/&gt;&lt;br/&gt;      COMMIT;&lt;br/&gt;      pkg_logging.end_process (l_process_rec, pkg_utility.c_process_success);&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos; || pkg_utility.c_proc_end_text&lt;br/&gt;                            );&lt;br/&gt;   EXCEPTION&lt;br/&gt;      WHEN exp_recon_run&lt;br/&gt;      THEN&lt;br/&gt;         ROLLBACK;&lt;br/&gt;         pkg_logging.log_exception&lt;br/&gt;                  (l_process_rec,&lt;br/&gt;                      l_proc_name&lt;br/&gt;                   || &apos;, exception=  Previous Reconciliation is in Progress &apos;&lt;br/&gt;                   || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                  );&lt;br/&gt;         pkg_logging.end_process (l_process_rec, pkg_utility.c_process_error);&lt;br/&gt;         pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                                   l_proc_name&lt;br/&gt;                                || &apos; &apos;&lt;br/&gt;                                || pkg_utility.c_process_error&lt;br/&gt;                               );&lt;br/&gt;         raise_application_error (-20001,&lt;br/&gt;                                  &apos;Previous Reconciliation is in Progress&apos;&lt;br/&gt;                                 );&lt;br/&gt;      WHEN exp_old_recon&lt;br/&gt;      THEN&lt;br/&gt;         ROLLBACK;&lt;br/&gt;         pkg_logging.log_exception&lt;br/&gt;            (l_process_rec,&lt;br/&gt;                l_proc_name&lt;br/&gt;             || &apos;, exception=  Current Recon Date less than the Previous Recon Date &apos;&lt;br/&gt;             || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;            );&lt;br/&gt;         pkg_logging.end_process (l_process_rec, pkg_utility.c_process_error);&lt;br/&gt;         pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                                   l_proc_name&lt;br/&gt;                                || &apos; &apos;&lt;br/&gt;                                || pkg_utility.c_process_error&lt;br/&gt;                               );&lt;br/&gt;         raise_application_error&lt;br/&gt;              (-20001,&lt;br/&gt;               &apos;Current Recon Date less than the Previous Reconciliation Date&apos;&lt;br/&gt;              );&lt;br/&gt;      WHEN OTHERS&lt;br/&gt;      THEN&lt;br/&gt;         ROLLBACK;&lt;br/&gt;         pkg_logging.log_exception (l_process_rec,&lt;br/&gt;                                       l_proc_name&lt;br/&gt;                                    || &apos;, EXCEPTION = &apos;&lt;br/&gt;                                    || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                                   );&lt;br/&gt;         pkg_logging.end_process (l_process_rec, pkg_utility.c_process_error);&lt;br/&gt;         pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                                   l_proc_name&lt;br/&gt;                                || &apos; &apos;&lt;br/&gt;                                || pkg_utility.c_process_error&lt;br/&gt;                               );&lt;br/&gt;         RAISE;&lt;br/&gt;   END insert_recon_process_ctrl;&lt;br/&gt;&lt;br/&gt;   PROCEDURE audit_recon_process_populate (&lt;br/&gt;      p_process_rec_i     IN   pkg_logging.t_process_rec,&lt;br/&gt;      p_table_name        IN   VARCHAR2,&lt;br/&gt;      p_table_key         IN   VARCHAR2,&lt;br/&gt;      p_modif_values      IN   VARCHAR2,&lt;br/&gt;      p_account_details   IN   VARCHAR2,&lt;br/&gt;      p_operation_perf    IN   VARCHAR2,&lt;br/&gt;      p_audit_user_i      IN   VARCHAR2&lt;br/&gt;   )&lt;br/&gt;   /****************************************************************************************************************&lt;br/&gt;   ||  SubProgram Name    : AUDIT_RECON_PROCESS_POPULATE&lt;br/&gt;   ||  Estimated Run Time :&lt;br/&gt;   ||  Description        : This is for Populating the log table audit_recon_process with the details of&lt;br/&gt;   ||                       updates/inserts in reconciliation process.&lt;br/&gt;   ******************************************************************************************************************/&lt;br/&gt;   IS&lt;br/&gt;      l_recon_process_id   stg.recon_process_ctrl.recon_process_id%TYPE;&lt;br/&gt;   BEGIN&lt;br/&gt;      IF (p_process_rec_i.log_level &gt; pkg_utility.c_logging_off)&lt;br/&gt;      THEN&lt;br/&gt;         SELECT recon_process_id&lt;br/&gt;           INTO l_recon_process_id&lt;br/&gt;           FROM stg.recon_process_ctrl&lt;br/&gt;          WHERE record_stat = &apos;I&apos;;&lt;br/&gt;&lt;br/&gt;         INSERT INTO stg.audit_recon_process&lt;br/&gt;                     (audit_recon_process_id, process_id,&lt;br/&gt;                      table_name, table_key, modif_values,&lt;br/&gt;                      account_details, operation_perf, record_stat,&lt;br/&gt;                      created_dttm, created_by&lt;br/&gt;                     )&lt;br/&gt;              VALUES (l_recon_process_id, p_process_rec_i.process_id,&lt;br/&gt;                      p_table_name, p_table_key, p_modif_values,&lt;br/&gt;                      p_account_details, p_operation_perf, &apos;A&apos;,&lt;br/&gt;                      SYSTIMESTAMP, p_audit_user_i&lt;br/&gt;                     );&lt;br/&gt;      END IF;&lt;br/&gt;   END audit_recon_process_populate;&lt;br/&gt;&lt;br/&gt;   PROCEDURE update_recon_process_ctrl (&lt;br/&gt;      p_recon_mode          VARCHAR2,&lt;br/&gt;      p_audit_user_i   IN   VARCHAR2&lt;br/&gt;   )&lt;br/&gt;   /****************************************************************************************************************&lt;br/&gt;   ||  SubProgram Name    : UPDATE_RECON_PROCESS_CTRL&lt;br/&gt;   ||  Estimated Run Time :&lt;br/&gt;   ||  Description        : This is for Updating  the table STG.RECON_PROCESS_CTRL at the end of the Recociliation process&lt;br/&gt;   ******************************************************************************************************************/&lt;br/&gt;   IS&lt;br/&gt;      l_proc_name      VARCHAR2 (30)           := &apos;UPDATE_RECON_PROCESS_CTRL&apos;;&lt;br/&gt;      l_process_name   t_process_log.process_name%TYPE          := c_pkg_name;&lt;br/&gt;      l_process_rec    pkg_logging.t_process_rec;&lt;br/&gt;      l_systimestamp   TIMESTAMP;&lt;br/&gt;      l_recon_date     stg.recon_process_ctrl.recon_date%TYPE;&lt;br/&gt;      lv_error_msg     VARCHAR2 (1200);&lt;br/&gt;   BEGIN&lt;br/&gt;      l_process_rec.process_name := l_process_name;&lt;br/&gt;      l_systimestamp := SYSTIMESTAMP;&lt;br/&gt;      pkg_logging.begin_process (l_process_rec,&lt;br/&gt;                                 &apos;p_audit_user_i=&apos; || p_audit_user_i&lt;br/&gt;                                );&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos;&lt;br/&gt;                             || pkg_utility.c_proc_start_text&lt;br/&gt;                            );&lt;br/&gt;&lt;br/&gt;      IF pkg_utility.stopnow (c_pkg_name)&lt;br/&gt;      THEN&lt;br/&gt;         RETURN;&lt;br/&gt;      END IF;&lt;br/&gt;&lt;br/&gt;      -- Exeute the Back up script&lt;br/&gt;      BEGIN&lt;br/&gt;         stg.pkg_stg_pre_process.swap_cur_bkp_tbl (p_audit_user_i);&lt;br/&gt;      EXCEPTION&lt;br/&gt;         WHEN OTHERS&lt;br/&gt;         THEN&lt;br/&gt;            lv_error_msg := SUBSTR (SQLERRM, 1, 1024);&lt;br/&gt;            pkg_logging.log_exception (l_process_rec,&lt;br/&gt;                                          l_proc_name&lt;br/&gt;                                       || &apos;, EXCEPTION = &apos;&lt;br/&gt;                                       || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                                      );&lt;br/&gt;            pkg_logging.end_process (l_process_rec,&lt;br/&gt;                                     pkg_utility.c_process_error&lt;br/&gt;                                    );&lt;br/&gt;            pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                                      l_proc_name&lt;br/&gt;                                   || &apos; &apos;&lt;br/&gt;                                   || pkg_utility.c_process_error&lt;br/&gt;                                  );&lt;br/&gt;            raise_application_error (-20004, lv_error_msg, FALSE);&lt;br/&gt;      END;&lt;br/&gt;&lt;br/&gt;      UPDATE stg.recon_process_ctrl&lt;br/&gt;         SET record_stat = pkg_utility.c_stg_processed,&lt;br/&gt;             recon_end_dttm = l_systimestamp,&lt;br/&gt;             modified_by = p_audit_user_i,&lt;br/&gt;             modified_dttm = l_systimestamp&lt;br/&gt;       WHERE record_stat = pkg_utility.c_stg_in_progress&lt;br/&gt;         AND recon_mode = p_recon_mode;&lt;br/&gt;&lt;br/&gt;      COMMIT;&lt;br/&gt;      pkg_logging.end_process (l_process_rec, pkg_utility.c_process_success);&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos; || pkg_utility.c_proc_end_text&lt;br/&gt;                            );&lt;br/&gt;   EXCEPTION&lt;br/&gt;      WHEN OTHERS&lt;br/&gt;      THEN&lt;br/&gt;         ROLLBACK;&lt;br/&gt;         pkg_logging.log_exception (l_process_rec,&lt;br/&gt;                                       l_proc_name&lt;br/&gt;                                    || &apos;, EXCEPTION = &apos;&lt;br/&gt;                                    || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                                   );&lt;br/&gt;         pkg_logging.end_process (l_process_rec, pkg_utility.c_process_error);&lt;br/&gt;         pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                                   l_proc_name&lt;br/&gt;                                || &apos; &apos;&lt;br/&gt;                                || pkg_utility.c_process_error&lt;br/&gt;                               );&lt;br/&gt;         RAISE;&lt;br/&gt;   END update_recon_process_ctrl;&lt;br/&gt;&lt;br/&gt;   PROCEDURE update_recon_key_tables (&lt;br/&gt;      p_recon_mode          VARCHAR2,&lt;br/&gt;      p_audit_user_i   IN   VARCHAR2&lt;br/&gt;   )&lt;br/&gt;   /****************************************************************************************************************&lt;br/&gt;   ||  SubProgram Name    : UPDATE_RECON_KEY_TABLES&lt;br/&gt;   ||  Estimated Run Time :&lt;br/&gt;   ||  Description        : This is for updating all the key table snad the Ondemand table at the end&lt;br/&gt;   ||                       of the Recociliation process to record_stat=&apos;P&apos;&lt;br/&gt;   ******************************************************************************************************************/&lt;br/&gt;   IS&lt;br/&gt;      l_proc_name      VARCHAR2 (30)             := &apos;UPDATE_RECON_KEY_TABLES&apos;;&lt;br/&gt;      l_process_name   t_process_log.process_name%TYPE          := c_pkg_name;&lt;br/&gt;      l_process_rec    pkg_logging.t_process_rec;&lt;br/&gt;      l_systimestamp   TIMESTAMP;&lt;br/&gt;      l_recon_date     stg.recon_process_ctrl.recon_date%TYPE;&lt;br/&gt;   BEGIN&lt;br/&gt;      l_process_rec.process_name := l_process_name;&lt;br/&gt;      l_systimestamp := SYSTIMESTAMP;&lt;br/&gt;      pkg_logging.begin_process (l_process_rec,&lt;br/&gt;                                 &apos;p_audit_user_i=&apos; || p_audit_user_i&lt;br/&gt;                                );&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos;&lt;br/&gt;                             || pkg_utility.c_proc_start_text&lt;br/&gt;                            );&lt;br/&gt;&lt;br/&gt;      IF pkg_utility.stopnow (c_pkg_name)&lt;br/&gt;      THEN&lt;br/&gt;         RETURN;&lt;br/&gt;      END IF;&lt;br/&gt;&lt;br/&gt;      --Updating all the key tables and On Demand account&lt;br/&gt;      IF p_recon_mode = pkg_utility.c_recon_mode_ond&lt;br/&gt;      THEN&lt;br/&gt;         UPDATE stg.vnt_ond_rec_key_sbb&lt;br/&gt;            SET record_stat = pkg_utility.c_stg_processed,&lt;br/&gt;                modified_dttm = l_systimestamp,&lt;br/&gt;                modified_by = p_audit_user_i&lt;br/&gt;          WHERE recon_mode = p_recon_mode;&lt;br/&gt;&lt;br/&gt;         UPDATE stg.vnt_ond_rec_key_hsl&lt;br/&gt;            SET record_stat = pkg_utility.c_stg_processed,&lt;br/&gt;                modified_dttm = l_systimestamp,&lt;br/&gt;                modified_by = p_audit_user_i&lt;br/&gt;          WHERE recon_mode = p_recon_mode;&lt;br/&gt;&lt;br/&gt;         UPDATE stg.vnt_ond_rec_key_cus&lt;br/&gt;            SET record_stat = pkg_utility.c_stg_processed,&lt;br/&gt;                modified_dttm = l_systimestamp,&lt;br/&gt;                modified_by = p_audit_user_i&lt;br/&gt;          WHERE recon_mode = p_recon_mode;&lt;br/&gt;&lt;br/&gt;         UPDATE stg.vnt_ond_rec_key_hse&lt;br/&gt;            SET record_stat = pkg_utility.c_stg_processed,&lt;br/&gt;                modified_dttm = l_systimestamp,&lt;br/&gt;                modified_by = p_audit_user_i&lt;br/&gt;          WHERE recon_mode = p_recon_mode;&lt;br/&gt;&lt;br/&gt;         UPDATE stg.vnt_ond_rec_key_oci&lt;br/&gt;            SET record_stat = pkg_utility.c_stg_processed,&lt;br/&gt;                modified_dttm = l_systimestamp,&lt;br/&gt;                modified_by = p_audit_user_i&lt;br/&gt;          WHERE recon_mode = p_recon_mode;&lt;br/&gt;&lt;br/&gt;         UPDATE stg.vnt_ond_rec_key_opi&lt;br/&gt;            SET record_stat = pkg_utility.c_stg_processed,&lt;br/&gt;                modified_dttm = l_systimestamp,&lt;br/&gt;                modified_by = p_audit_user_i&lt;br/&gt;          WHERE recon_mode = p_recon_mode;&lt;br/&gt;&lt;br/&gt;         UPDATE stg.vnt_ond_rec_key_order&lt;br/&gt;            SET record_stat = pkg_utility.c_stg_processed,&lt;br/&gt;                modified_dttm = l_systimestamp,&lt;br/&gt;                modified_by = p_audit_user_i&lt;br/&gt;          WHERE recon_mode = p_recon_mode;&lt;br/&gt;&lt;br/&gt;         UPDATE stg.vnt_ond_rec_key_otr&lt;br/&gt;            SET record_stat = pkg_utility.c_stg_processed,&lt;br/&gt;                modified_dttm = l_systimestamp,&lt;br/&gt;                modified_by = p_audit_user_i&lt;br/&gt;          WHERE recon_mode = p_recon_mode;&lt;br/&gt;&lt;br/&gt;         UPDATE stg.vnt_ond_rec_key_ojb&lt;br/&gt;            SET record_stat = pkg_utility.c_stg_processed,&lt;br/&gt;                modified_dttm = l_systimestamp,&lt;br/&gt;                modified_by = p_audit_user_i&lt;br/&gt;          WHERE recon_mode = p_recon_mode;&lt;br/&gt;      ELSE&lt;br/&gt;         UPDATE stg.vnt_ond_rec_key_sbb&lt;br/&gt;            SET record_stat = pkg_utility.c_stg_processed,&lt;br/&gt;                modified_dttm = l_systimestamp,&lt;br/&gt;                modified_by = p_audit_user_i;&lt;br/&gt;&lt;br/&gt;         UPDATE stg.vnt_ond_rec_key_hsl&lt;br/&gt;            SET record_stat = pkg_utility.c_stg_processed,&lt;br/&gt;                modified_dttm = l_systimestamp,&lt;br/&gt;                modified_by = p_audit_user_i;&lt;br/&gt;&lt;br/&gt;         UPDATE stg.vnt_ond_rec_key_cus&lt;br/&gt;            SET record_stat = pkg_utility.c_stg_processed,&lt;br/&gt;                modified_dttm = l_systimestamp,&lt;br/&gt;                modified_by = p_audit_user_i;&lt;br/&gt;&lt;br/&gt;         UPDATE stg.vnt_ond_rec_key_hse&lt;br/&gt;            SET record_stat = pkg_utility.c_stg_processed,&lt;br/&gt;                modified_dttm = l_systimestamp,&lt;br/&gt;                modified_by = p_audit_user_i;&lt;br/&gt;&lt;br/&gt;         UPDATE stg.vnt_ond_rec_key_oci&lt;br/&gt;            SET record_stat = pkg_utility.c_stg_processed,&lt;br/&gt;                modified_dttm = l_systimestamp,&lt;br/&gt;                modified_by = p_audit_user_i;&lt;br/&gt;&lt;br/&gt;         UPDATE stg.vnt_ond_rec_key_opi&lt;br/&gt;            SET record_stat = pkg_utility.c_stg_processed,&lt;br/&gt;                modified_dttm = l_systimestamp,&lt;br/&gt;                modified_by = p_audit_user_i;&lt;br/&gt;&lt;br/&gt;         UPDATE stg.vnt_ond_rec_key_order&lt;br/&gt;            SET record_stat = pkg_utility.c_stg_processed,&lt;br/&gt;                modified_dttm = l_systimestamp,&lt;br/&gt;                modified_by = p_audit_user_i;&lt;br/&gt;&lt;br/&gt;         UPDATE stg.vnt_ond_rec_key_otr&lt;br/&gt;            SET record_stat = pkg_utility.c_stg_processed,&lt;br/&gt;                modified_dttm = l_systimestamp,&lt;br/&gt;                modified_by = p_audit_user_i;&lt;br/&gt;&lt;br/&gt;         UPDATE stg.vnt_ond_rec_key_ojb&lt;br/&gt;            SET record_stat = pkg_utility.c_stg_processed,&lt;br/&gt;                modified_dttm = l_systimestamp,&lt;br/&gt;                modified_by = p_audit_user_i;&lt;br/&gt;      END IF;&lt;br/&gt;&lt;br/&gt;      --Updating On Demand Account&lt;br/&gt;      UPDATE stg.vnt_rec_ond_acct&lt;br/&gt;         SET record_stat = pkg_utility.c_stg_processed,&lt;br/&gt;             modified_dttm = l_systimestamp,&lt;br/&gt;             modified_by = p_audit_user_i;&lt;br/&gt;&lt;br/&gt;      --Commented below update on 13-May-2015 as this UPDATE is present in next process also as duplicate&lt;br/&gt;      --  --Updating Process Control table&lt;br/&gt;      --  UPDATE stg.recon_process_ctrl&lt;br/&gt;      --     SET record_stat = pkg_utility.c_stg_processed,&lt;br/&gt;      --         recon_end_dttm = l_systimestamp,&lt;br/&gt;      --         modified_by = p_audit_user_i,&lt;br/&gt;      --         modified_dttm = l_systimestamp&lt;br/&gt;      --    WHERE record_stat =pkg_utility.c_stg_in_progress&lt;br/&gt;      --     AND recon_mode=p_recon_mode;&lt;br/&gt;      COMMIT;&lt;br/&gt;      pkg_logging.end_process (l_process_rec, pkg_utility.c_process_success);&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos; || pkg_utility.c_proc_end_text&lt;br/&gt;                            );&lt;br/&gt;   EXCEPTION&lt;br/&gt;      WHEN OTHERS&lt;br/&gt;      THEN&lt;br/&gt;         ROLLBACK;&lt;br/&gt;         pkg_logging.log_exception (l_process_rec,&lt;br/&gt;                                       l_proc_name&lt;br/&gt;                                    || &apos;, EXCEPTION = &apos;&lt;br/&gt;                                    || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                                   );&lt;br/&gt;         pkg_logging.end_process (l_process_rec, pkg_utility.c_process_error);&lt;br/&gt;         pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                                   l_proc_name&lt;br/&gt;                                || &apos; &apos;&lt;br/&gt;                                || pkg_utility.c_process_error&lt;br/&gt;                               );&lt;br/&gt;         RAISE;&lt;br/&gt;   END update_recon_key_tables;&lt;br/&gt;END pkg_vnt_recon_process;</source>
</body>
</PackageOracle>
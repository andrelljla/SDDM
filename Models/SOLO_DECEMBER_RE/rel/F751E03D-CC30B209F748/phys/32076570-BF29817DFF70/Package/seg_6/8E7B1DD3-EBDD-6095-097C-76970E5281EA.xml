<?xml version = '1.0' encoding = 'UTF-8'?>
<PackageOracle class="oracle.dbtools.crest.model.design.storage.oracle.PackageOracle" name="PKG_VNT_LOAD_NQL_HIST" directorySegmentName="seg_6" id="8E7B1DD3-EBDD-6095-097C-76970E5281EA">
<sourceConnName>SOLO_Prod</sourceConnName>
<sourceObjSchema>CHTR</sourceObjSchema>
<sourceObjName>PKG_VNT_LOAD_NQL_HIST</sourceObjName>
<createdBy>jandrews1</createdBy>
<createdTime>2015-08-11 13:17:39 UTC</createdTime>
<ownerDesignName>SOLO_DECEMBER_RE</ownerDesignName>
<owner>5AF9E3FC-7A76-C437-3E83-BF29D7EA2FC7</owner>
<source>CREATE OR REPLACE PACKAGE      CHTR.PKG_VNT_LOAD_NQL_HIST&lt;br/&gt;/****************************************************************************************************************&lt;br/&gt;||Program Name    : pkg_vnt_load_nql_hist&lt;br/&gt;||Created By      : knoll&lt;br/&gt;||Created Date    : 10-Dec-2014&lt;br/&gt;||Subject Area    : Equipment&lt;br/&gt;||Description     : The package pkg_vnt_load_nql_hist controls the initial load of the Vantage&lt;br/&gt;||                  nql_hist table into SOLODB.&lt;br/&gt;||Change log      :&lt;br/&gt;||&lt;br/&gt;||    Changed By      Changed On      Change Description&lt;br/&gt;||  -------------------------------------------------------------------------------------------------------------&lt;br/&gt;||   knoll            Feb-2015        Rework.&lt;br/&gt;******************************************************************************************************************/&lt;br/&gt;IS&lt;br/&gt;PROCEDURE load(&lt;br/&gt;         p_audit_user_i IN VARCHAR2,&lt;br/&gt;         p_this_thread NUMBER DEFAULT 1,&lt;br/&gt;         p_max_thread NUMBER DEFAULT 1,&lt;br/&gt;         p_batchsize   NUMBER DEFAULT 5000);&lt;br/&gt;&lt;br/&gt;PROCEDURE finalize(&lt;br/&gt;         p_audit_user_i IN VARCHAR2);&lt;br/&gt;&lt;br/&gt;END pkg_vnt_load_nql_hist;</source>
<body class="oracle.dbtools.crest.model.design.storage.oracle.PackageBodyOracle" name="PKG_VNT_LOAD_NQL_HIST" id="8E7B1DD3-EBDD-6095-097C-76970E5281EA">
<sourceConnName>SOLO_Prod</sourceConnName>
<sourceObjSchema>CHTR</sourceObjSchema>
<sourceObjName>PKG_VNT_LOAD_NQL_HIST</sourceObjName>
<createdBy>jandrews1</createdBy>
<createdTime>2015-08-11 13:17:41 UTC</createdTime>
<ownerDesignName>SOLO_DECEMBER_RE</ownerDesignName>
<owner>5AF9E3FC-7A76-C437-3E83-BF29D7EA2FC7</owner>
<source>CREATE OR REPLACE PACKAGE BODY      CHTR.PKG_VNT_LOAD_NQL_HIST&lt;br/&gt;IS&lt;br/&gt;   /****************************************************************************************************************&lt;br/&gt;   ||  Program Name    : pkg_vnt_load_nql_hist&lt;br/&gt;   ||  Created By      : knoll&lt;br/&gt;   ||  Created Date    : 10-Dec-2014&lt;br/&gt;   ||  Subject Area    : Equipment&lt;br/&gt;   ||  Description     : The package pkg_vnt_load_nql_hist controls the initial load of the Vantage&lt;br/&gt;   ||                    nql_hist table into SOLODB.&lt;br/&gt;   ||  Change log      :&lt;br/&gt;   ||&lt;br/&gt;   ||    Changed By      Changed On      Change Description&lt;br/&gt;   ||  ----------------  --------------- ----------------------------------------------------------------------------&lt;br/&gt;   ||   Senthil          14-Jan-2015     Changed the cursor to eliminate the duplicate records&lt;br/&gt;   ||   knoll            Feb-2015        Reworked.  Use il tables.&lt;br/&gt;   ||&lt;br/&gt;   ******************************************************************************************************************/&lt;br/&gt;   SUBTYPE t_unit_name IS VARCHAR2 (30);&lt;br/&gt;&lt;br/&gt;   -- CONSTANTS&lt;br/&gt;   c_stg_processed CONSTANT VARCHAR2 (1) := &apos;P&apos;;&lt;br/&gt;   c_stg_in_progress CONSTANT VARCHAR2 (1) := &apos;I&apos;;&lt;br/&gt;   c_stg_error CONSTANT VARCHAR2 (1) := &apos;E&apos;;&lt;br/&gt;   c_pkg_name CONSTANT t_unit_name := &apos;PKG_VNT_LOAD_NQL_HIST&apos;;&lt;br/&gt;   c_null_date CONSTANT DATE := TO_DATE (&apos;00010101&apos;, &apos;YYYYMMDD&apos;);&lt;br/&gt;   -- EXCEPTION CONSTANTS&lt;br/&gt;   c_bulk_errors EXCEPTION;&lt;br/&gt;   PRAGMA EXCEPTION_INIT (c_bulk_errors, -24381);&lt;br/&gt;   -- THREADING BIND VARIABLES&lt;br/&gt;   g_this_thread NUMBER := 1;&lt;br/&gt;   g_max_thread NUMBER := 1;&lt;br/&gt;   g_batchsize NUMBER := 1000;&lt;br/&gt;&lt;br/&gt;   -- CURSORS&lt;br/&gt;   -- Staged nql_hist for loading&lt;br/&gt;   CURSOR cur_stg_nql_hist&lt;br/&gt;   IS&lt;br/&gt;   WITH&lt;br/&gt;      addr AS&lt;br/&gt;      (&lt;br/&gt;         SELECT&lt;br/&gt;            /*+ parallel(eb 8) */&lt;br/&gt;            sys_eqp,&lt;br/&gt;            prin_eqp,&lt;br/&gt;            TRIM(UPPER(eqp_serial_eqp)) eqp_serial_eqp,&lt;br/&gt;            NVL(TRIM(UPPER(MAX(eqp_make_eqp))), &apos;UNKNOWN&apos; ) eqp_make_eqp,&lt;br/&gt;            NVL(TRIM(UPPER(MAX(eqp_model_eqp))), &apos;UNKNOWN&apos; ) eqp_model_eqp,&lt;br/&gt;            MIN(create_dte_eqp) create_dte_eqp&lt;br/&gt;         FROM&lt;br/&gt;            stg.vnt_eqp_base_il eb&lt;br/&gt;         GROUP BY&lt;br/&gt;            sys_eqp,&lt;br/&gt;            prin_eqp,&lt;br/&gt;            TRIM(UPPER(eqp_serial_eqp))&lt;br/&gt;      )&lt;br/&gt;   ,&lt;br/&gt;   equip AS&lt;br/&gt;   (&lt;br/&gt;      SELECT&lt;br/&gt;         /*+ parallel(nh 8) */&lt;br/&gt;         sys_nql,&lt;br/&gt;         prin_nql,&lt;br/&gt;         ROWID AS ID,&lt;br/&gt;         record_load_cd,&lt;br/&gt;         eqp_local_nql,&lt;br/&gt;         TRIM(eqp_typ_nql) AS eqp_typ_nql,&lt;br/&gt;         TRIM(eqp_stat_nql) AS eqp_stat_nql,&lt;br/&gt;         TRIM(UPPER(eqp_serial_nql)) AS eqp_serial_nql,&lt;br/&gt;         eqp_cmpnt_nql,&lt;br/&gt;         curr_rec_ind_nql&lt;br/&gt;      FROM&lt;br/&gt;         stg.vnt_nql_hist_il nh&lt;br/&gt;   )&lt;br/&gt;SELECT&lt;br/&gt;   s_product_instance_id.NEXTVAL AS product_instance_id,&lt;br/&gt;   &apos;VNT&apos; AS data_source_type_cd,&lt;br/&gt;   equip.ID,&lt;br/&gt;   equip.record_load_cd,&lt;br/&gt;   ep.equipment_product_id,&lt;br/&gt;   xref.account_id,&lt;br/&gt;   equip.eqp_local_nql AS account_num,&lt;br/&gt;   addr.eqp_model_eqp AS equipment_model_num,&lt;br/&gt;   addr.eqp_make_eqp AS manufacturer,&lt;br/&gt;   equip.eqp_serial_nql AS equipment_esn_val,&lt;br/&gt;   equip.eqp_typ_nql AS equip_prod_inst_type_cd,&lt;br/&gt;   equip.eqp_stat_nql AS equip_prod_inst_status_cd,&lt;br/&gt;   addr.create_dte_eqp,&lt;br/&gt;   &apos;EQPMT&apos; product_instance_type_cd&lt;br/&gt;FROM&lt;br/&gt;   equip&lt;br/&gt;INNER JOIN addr&lt;br/&gt;ON&lt;br/&gt;   (&lt;br/&gt;      addr.sys_eqp = equip.sys_nql&lt;br/&gt;      AND addr.prin_eqp = equip.prin_nql&lt;br/&gt;      AND addr.eqp_serial_eqp = equip.eqp_serial_nql&lt;br/&gt;   )&lt;br/&gt;INNER JOIN t_equip_product ep&lt;br/&gt;ON&lt;br/&gt;   (&lt;br/&gt;      ep.equipment_model_num = addr.eqp_model_eqp&lt;br/&gt;   )&lt;br/&gt;LEFT OUTER JOIN t_account_vantage_xref xref&lt;br/&gt;ON&lt;br/&gt;   (&lt;br/&gt;      xref.sub_acct_num = equip.eqp_local_nql&lt;br/&gt;   )&lt;br/&gt;WHERE&lt;br/&gt;   equip.curr_rec_ind_nql = &apos;Y&apos;&lt;br/&gt;   AND equip.eqp_cmpnt_nql IN (&apos;00&apos;, &apos;01&apos;)&lt;br/&gt;   AND equip.record_load_cd IS NULL&lt;br/&gt;;&lt;br/&gt;&lt;br/&gt;TYPE t_cursor_data_tbl&lt;br/&gt;IS&lt;br/&gt;   TABLE OF cur_stg_nql_hist%ROWTYPE INDEX BY PLS_INTEGER;&lt;br/&gt;&lt;br/&gt;TYPE t_ptr_tbl&lt;br/&gt;IS&lt;br/&gt;   TABLE OF PLS_INTEGER INDEX BY PLS_INTEGER;&lt;br/&gt;&lt;br/&gt;   -- Forward declarations&lt;br/&gt;PROCEDURE insert_product_instance(&lt;br/&gt;      p_process_rec_i IN pkg_logging.t_process_rec,&lt;br/&gt;      p_cursor_data_io IN OUT NOCOPY t_cursor_data_tbl );&lt;br/&gt;&lt;br/&gt;PROCEDURE insert_equip_prod_inst(&lt;br/&gt;      p_process_rec_i IN pkg_logging.t_process_rec,&lt;br/&gt;      p_cursor_data_io IN OUT NOCOPY t_cursor_data_tbl );&lt;br/&gt;&lt;br/&gt;PROCEDURE insert_settop_box_inst(&lt;br/&gt;      p_process_rec_i IN pkg_logging.t_process_rec,&lt;br/&gt;      p_cursor_data_io IN OUT NOCOPY t_cursor_data_tbl,&lt;br/&gt;      p_filter_i IN t_ptr_tbl );&lt;br/&gt;&lt;br/&gt;PROCEDURE insert_equip_instance_account(&lt;br/&gt;      p_process_rec_i IN pkg_logging.t_process_rec,&lt;br/&gt;      p_cursor_data_io IN OUT NOCOPY t_cursor_data_tbl,&lt;br/&gt;      p_filter_i IN t_ptr_tbl );&lt;br/&gt;&lt;br/&gt;   FUNCTION filter_equip_instance_account(&lt;br/&gt;         p_process_rec_i IN pkg_logging.t_process_rec,&lt;br/&gt;         p_cursor_data_i IN t_cursor_data_tbl )&lt;br/&gt;      RETURN t_ptr_tbl;&lt;br/&gt;&lt;br/&gt;   FUNCTION filter_settop_box_instance(&lt;br/&gt;         p_process_rec_i IN pkg_logging.t_process_rec,&lt;br/&gt;         p_cursor_data_i IN t_cursor_data_tbl )&lt;br/&gt;      RETURN t_ptr_tbl;&lt;br/&gt;&lt;br/&gt;   PROCEDURE update_staging(&lt;br/&gt;         p_process_rec_i IN pkg_logging.t_process_rec,&lt;br/&gt;         p_cursor_data_i IN t_cursor_data_tbl );&lt;br/&gt;&lt;br/&gt;   PROCEDURE load(&lt;br/&gt;         p_audit_user_i IN VARCHAR2,&lt;br/&gt;         p_this_thread NUMBER DEFAULT 1,&lt;br/&gt;         p_max_thread NUMBER DEFAULT 1,&lt;br/&gt;         p_batchsize NUMBER DEFAULT 5000 )&lt;br/&gt;   IS&lt;br/&gt;      /****************************************************************************************************************&lt;br/&gt;      ||  SubProgram Name    : Procedure LOAD&lt;br/&gt;      ||  Estimated Run Time :&lt;br/&gt;      ||  Description        : The LOAD procedure will open the cursor and start executing for each record&lt;br/&gt;      ||                       for Insert product_instance,Insert equip_prod_inst, Insert&lt;br/&gt;      ||                       settop_box_instance,Insert equipment_location, Insert equipment specifics,&lt;br/&gt;      ||                       settop_box, etc. with Update the staging rows with status&lt;br/&gt;      *****************************************************************************************************************&lt;br/&gt;      */&lt;br/&gt;      l_proc_name t_unit_name := &apos;LOAD&apos;;&lt;br/&gt;      l_process_name t_process_log.process_name%TYPE := c_pkg_name;&lt;br/&gt;      l_process_rec pkg_logging.t_process_rec;&lt;br/&gt;      l_cursor_data t_cursor_data_tbl;&lt;br/&gt;      l_filter_ptr t_ptr_tbl; -- for filtering data in the cursor table&lt;br/&gt;   BEGIN&lt;br/&gt;      l_process_rec.process_name := l_process_name;&lt;br/&gt;      pkg_logging.begin_process (l_process_rec, &apos;p_audit_user_i=&apos; || p_audit_user_i );&lt;br/&gt;      g_this_thread := p_this_thread;&lt;br/&gt;      g_max_thread := p_max_thread;&lt;br/&gt;      g_batchsize := p_batchsize;&lt;br/&gt;&lt;br/&gt;      IF pkg_utility.stopnow (c_pkg_name) THEN&lt;br/&gt;         RETURN;&lt;br/&gt;      END IF;&lt;br/&gt;&lt;br/&gt;      OPEN cur_stg_nql_hist;&lt;br/&gt;&lt;br/&gt;      LOOP&lt;br/&gt;         FETCH&lt;br/&gt;            cur_stg_nql_hist BULK COLLECT&lt;br/&gt;         INTO&lt;br/&gt;            l_cursor_data LIMIT g_batchsize;&lt;br/&gt;&lt;br/&gt;         IF (l_cursor_data.COUNT () &gt; 0) THEN&lt;br/&gt;            -- Insert product_instance&lt;br/&gt;            insert_product_instance (l_process_rec, l_cursor_data);&lt;br/&gt;            -- Insert equip_prod_inst&lt;br/&gt;            insert_equip_prod_inst (l_process_rec, l_cursor_data);&lt;br/&gt;            -- Insert equip_instance_account&lt;br/&gt;            l_filter_ptr.DELETE;&lt;br/&gt;            l_filter_ptr := filter_equip_instance_account (l_process_rec, l_cursor_data);&lt;br/&gt;            insert_equip_instance_account (l_process_rec, l_cursor_data, l_filter_ptr );&lt;br/&gt;            -- Insert settop_box_instance&lt;br/&gt;            l_filter_ptr.DELETE;&lt;br/&gt;            l_filter_ptr := filter_settop_box_instance (l_process_rec, l_cursor_data);&lt;br/&gt;            insert_settop_box_inst (l_process_rec, l_cursor_data, l_filter_ptr);&lt;br/&gt;            l_filter_ptr.DELETE;&lt;br/&gt;            -- Update the staging rows with status&lt;br/&gt;            update_staging (l_process_rec, l_cursor_data);&lt;br/&gt;            -- Commit the batch&lt;br/&gt;            COMMIT;&lt;br/&gt;         END IF;&lt;br/&gt;&lt;br/&gt;         EXIT&lt;br/&gt;      WHEN l_cursor_data.COUNT () &lt; g_batchsize OR pkg_utility.stopnow (c_pkg_name);&lt;br/&gt;      END LOOP;&lt;br/&gt;&lt;br/&gt;      CLOSE cur_stg_nql_hist;&lt;br/&gt;&lt;br/&gt;      pkg_logging.end_process (l_process_rec);&lt;br/&gt;   EXCEPTION&lt;br/&gt;   WHEN OTHERS THEN&lt;br/&gt;      IF (cur_stg_nql_hist%ISOPEN) THEN&lt;br/&gt;         CLOSE cur_stg_nql_hist;&lt;br/&gt;      END IF;&lt;br/&gt;&lt;br/&gt;      ROLLBACK;&lt;br/&gt;      pkg_logging.end_process (l_process_rec, &apos;ERROR WHILE PROCESSING&apos;);&lt;br/&gt;      pkg_logging.log_exception (l_process_rec, DBMS_UTILITY.format_error_stack () );&lt;br/&gt;      RAISE;&lt;br/&gt;   END load;&lt;br/&gt;&lt;br/&gt;PROCEDURE insert_product_instance(&lt;br/&gt;      p_process_rec_i IN pkg_logging.t_process_rec,&lt;br/&gt;      p_cursor_data_io IN OUT NOCOPY t_cursor_data_tbl )&lt;br/&gt;IS&lt;br/&gt;   /****************************************************************************************************************&lt;br/&gt;   ||  SubProgram Name    : Procedure insert_product_instance&lt;br/&gt;   ||  Estimated Run Time :&lt;br/&gt;   ||  Description        : The insert_product_instance procedure will Insert product_instance rows from staging data&lt;br/&gt;   ******************************************************************************************************************/&lt;br/&gt;   l_proc_name t_unit_name := &apos;INSERT_PRODUCT_INSTANCE&apos;;&lt;br/&gt;   l_errors NUMBER;&lt;br/&gt;   l_coll_idx PLS_INTEGER;&lt;br/&gt;BEGIN&lt;br/&gt;   pkg_logging.log_debug (p_process_rec_i, l_proc_name || &apos;, cnt=&apos; || p_cursor_data_io.COUNT () );&lt;br/&gt;&lt;br/&gt;   BEGIN&lt;br/&gt;      FORALL i IN 1 .. p_cursor_data_io.COUNT SAVE EXCEPTIONS&lt;br/&gt;      INSERT&lt;br/&gt;      INTO&lt;br/&gt;         t_product_instance a&lt;br/&gt;         (&lt;br/&gt;            a.product_instance_id,&lt;br/&gt;            a.product_id,&lt;br/&gt;            a.product_instance_type_cd,&lt;br/&gt;            a.data_load_type_cd,&lt;br/&gt;            a.data_source_type_cd,&lt;br/&gt;            a.record_stat,&lt;br/&gt;            a.created_dttm,&lt;br/&gt;            a.created_by&lt;br/&gt;         )&lt;br/&gt;         VALUES&lt;br/&gt;         (&lt;br/&gt;            p_cursor_data_io (i).product_instance_id,&lt;br/&gt;            p_cursor_data_io (i).equipment_product_id,&lt;br/&gt;            p_cursor_data_io (i).product_instance_type_cd,&lt;br/&gt;            &apos;NQL&apos;,&lt;br/&gt;            p_cursor_data_io (i).data_source_type_cd,&lt;br/&gt;            &apos;A&apos;,&lt;br/&gt;            SYSTIMESTAMP,&lt;br/&gt;            c_pkg_name&lt;br/&gt;         );&lt;br/&gt;   EXCEPTION&lt;br/&gt;   WHEN c_bulk_errors THEN&lt;br/&gt;      l_errors := SQL%BULK_EXCEPTIONS.COUNT;&lt;br/&gt;&lt;br/&gt;      FOR i IN 1 .. l_errors&lt;br/&gt;      LOOP&lt;br/&gt;         NULL;&lt;br/&gt;         l_coll_idx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;&lt;br/&gt;         p_cursor_data_io (l_coll_idx).record_load_cd := c_stg_error;&lt;br/&gt;         pkg_logging.log_exception (p_process_rec_i, l_proc_name || &apos;, bulk insert exception, key=&apos; || p_cursor_data_io&lt;br/&gt;         (l_coll_idx).account_num || &apos;:&apos; || p_cursor_data_io (l_coll_idx).equipment_esn_val || &apos;, exception=&apos; ||&lt;br/&gt;         SQL%BULK_EXCEPTIONS (i).ERROR_CODE );&lt;br/&gt;      END LOOP;&lt;br/&gt;   END;&lt;br/&gt;&lt;br/&gt;   pkg_logging.log_debug (p_process_rec_i, l_proc_name || &apos;, end&apos;);&lt;br/&gt;END insert_product_instance;&lt;br/&gt;&lt;br/&gt;PROCEDURE insert_equip_prod_inst&lt;br/&gt;   (&lt;br/&gt;      p_process_rec_i IN pkg_logging.t_process_rec,&lt;br/&gt;      p_cursor_data_io IN OUT NOCOPY t_cursor_data_tbl&lt;br/&gt;   )&lt;br/&gt;IS&lt;br/&gt;   /****************************************************************************************************************&lt;br/&gt;   ||  SubProgram Name    : Procedure insert_equip_prod_inst&lt;br/&gt;   ||  Estimated Run Time :&lt;br/&gt;   ||  Description        : The insert_equip_prod_inst procedure will Insert equip_prod_inst rows from staging data&lt;br/&gt;   ******************************************************************************************************************/&lt;br/&gt;   l_proc_name t_unit_name := &apos;INSERT_EQUIP_PROD_INST&apos;;&lt;br/&gt;   l_errors NUMBER;&lt;br/&gt;   l_coll_idx PLS_INTEGER;&lt;br/&gt;BEGIN&lt;br/&gt;   pkg_logging.log_debug (p_process_rec_i, l_proc_name || &apos;, cnt=&apos; || p_cursor_data_io.COUNT () );&lt;br/&gt;&lt;br/&gt;   BEGIN&lt;br/&gt;      FORALL i IN 1 .. p_cursor_data_io.COUNT SAVE EXCEPTIONS&lt;br/&gt;      INSERT&lt;br/&gt;      INTO&lt;br/&gt;         t_equip_prod_inst a&lt;br/&gt;         (&lt;br/&gt;            a.equip_prod_inst_id,&lt;br/&gt;            a.equipment_product_id,&lt;br/&gt;            a.equipment_esn_val,&lt;br/&gt;            a.equipment_cost_amt,&lt;br/&gt;            a.equip_prod_inst_type_cd,&lt;br/&gt;            a.equip_prod_inst_status_cd,&lt;br/&gt;            a.data_source_type_cd,&lt;br/&gt;            a.equip_mac_address_id,&lt;br/&gt;            a.equip_sec_mac_address_id,&lt;br/&gt;            a.record_stat,&lt;br/&gt;            a.created_dttm,&lt;br/&gt;            a.created_by&lt;br/&gt;         )&lt;br/&gt;         VALUES&lt;br/&gt;         (&lt;br/&gt;            p_cursor_data_io (i).product_instance_id,&lt;br/&gt;            p_cursor_data_io (i).equipment_product_id,&lt;br/&gt;            p_cursor_data_io (i).equipment_esn_val,&lt;br/&gt;            NULL,&lt;br/&gt;            p_cursor_data_io (i).equip_prod_inst_type_cd,&lt;br/&gt;            p_cursor_data_io (i).equip_prod_inst_status_cd,&lt;br/&gt;            p_cursor_data_io (i).data_source_type_cd,&lt;br/&gt;            NULL,&lt;br/&gt;            NULL,&lt;br/&gt;            &apos;A&apos;,&lt;br/&gt;            SYSTIMESTAMP,&lt;br/&gt;            c_pkg_name&lt;br/&gt;         );&lt;br/&gt;   EXCEPTION&lt;br/&gt;   WHEN c_bulk_errors THEN&lt;br/&gt;      l_errors := SQL%BULK_EXCEPTIONS.COUNT;&lt;br/&gt;&lt;br/&gt;      FOR i IN 1 .. l_errors&lt;br/&gt;      LOOP&lt;br/&gt;         NULL;&lt;br/&gt;         l_coll_idx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;&lt;br/&gt;         p_cursor_data_io (l_coll_idx).record_load_cd := c_stg_error;&lt;br/&gt;         pkg_logging.log_exception (p_process_rec_i, l_proc_name || &apos;, bulk insert exception, key=&apos; || p_cursor_data_io&lt;br/&gt;         (l_coll_idx).account_num || &apos;:&apos; || p_cursor_data_io (l_coll_idx).equipment_esn_val || &apos;, exception=&apos; ||&lt;br/&gt;         SQL%BULK_EXCEPTIONS (i).ERROR_CODE );&lt;br/&gt;      END LOOP;&lt;br/&gt;   END;&lt;br/&gt;&lt;br/&gt;   pkg_logging.log_debug (p_process_rec_i, l_proc_name || &apos;, end&apos;);&lt;br/&gt;END insert_equip_prod_inst;&lt;br/&gt;&lt;br/&gt;PROCEDURE insert_settop_box_inst&lt;br/&gt;   (&lt;br/&gt;      p_process_rec_i IN pkg_logging.t_process_rec,&lt;br/&gt;      p_cursor_data_io IN OUT NOCOPY t_cursor_data_tbl,&lt;br/&gt;      p_filter_i IN t_ptr_tbl&lt;br/&gt;   )&lt;br/&gt;IS&lt;br/&gt;   /****************************************************************************************************************&lt;br/&gt;   ||  SubProgram Name    : Procedure insert_settop_box_inst&lt;br/&gt;   ||  Estimated Run Time :&lt;br/&gt;   ||  Description        :  The insert_settop_box_inst procedure will Insert t_settop_box_instance data&lt;br/&gt;   ******************************************************************************************************************/&lt;br/&gt;   l_proc_name t_unit_name := &apos;INSERT_SETTOP_BOX_INST&apos;;&lt;br/&gt;   l_errors NUMBER;&lt;br/&gt;   l_coll_idx PLS_INTEGER;&lt;br/&gt;BEGIN&lt;br/&gt;   pkg_logging.log_debug (p_process_rec_i, l_proc_name || &apos;, cnt=&apos; || p_filter_i.COUNT () );&lt;br/&gt;&lt;br/&gt;   BEGIN&lt;br/&gt;      FORALL i IN VALUES OF p_filter_i SAVE EXCEPTIONS&lt;br/&gt;      INSERT&lt;br/&gt;      INTO&lt;br/&gt;         t_settop_box_instance a&lt;br/&gt;         (&lt;br/&gt;            settop_box_instance_id,&lt;br/&gt;            serial_num,&lt;br/&gt;            model_nm,&lt;br/&gt;            soc_part_num,&lt;br/&gt;            manufacturer,&lt;br/&gt;            manufacturer_site,&lt;br/&gt;            manufacturer_date,&lt;br/&gt;            cas_id,&lt;br/&gt;            estb_mac_address,&lt;br/&gt;            ecm_mac_address,&lt;br/&gt;            ethernet_mac_address,&lt;br/&gt;            cmci_mac_address,&lt;br/&gt;            rf4ce_mac_address,&lt;br/&gt;            record_stat,&lt;br/&gt;            created_dttm,&lt;br/&gt;            created_by&lt;br/&gt;         )&lt;br/&gt;         VALUES&lt;br/&gt;         (&lt;br/&gt;            p_cursor_data_io (i).product_instance_id,&lt;br/&gt;            p_cursor_data_io (i).equipment_esn_val,&lt;br/&gt;            p_cursor_data_io (i).equipment_model_num,&lt;br/&gt;            NULL,&lt;br/&gt;            p_cursor_data_io (i).manufacturer,&lt;br/&gt;            NULL,&lt;br/&gt;            p_cursor_data_io (i).create_dte_eqp,&lt;br/&gt;            DECODE(p_cursor_data_io (i).manufacturer,&apos;WLDBX&apos;,&apos;UNKNOWN&apos;,NULL),&lt;br/&gt;            NULL,&lt;br/&gt;            NULL,&lt;br/&gt;            NULL,&lt;br/&gt;            NULL,&lt;br/&gt;            NULL,&lt;br/&gt;            &apos;A&apos;,&lt;br/&gt;            SYSTIMESTAMP,&lt;br/&gt;            c_pkg_name&lt;br/&gt;         );&lt;br/&gt;   EXCEPTION&lt;br/&gt;   WHEN c_bulk_errors THEN&lt;br/&gt;      l_errors := SQL%BULK_EXCEPTIONS.COUNT;&lt;br/&gt;&lt;br/&gt;      FOR i IN 1 .. l_errors&lt;br/&gt;      LOOP&lt;br/&gt;         NULL;&lt;br/&gt;         l_coll_idx := p_filter_i (SQL%BULK_EXCEPTIONS (i).ERROR_INDEX);&lt;br/&gt;         p_cursor_data_io (l_coll_idx).record_load_cd := c_stg_error;&lt;br/&gt;         pkg_logging.log_exception (p_process_rec_i, l_proc_name || &apos;, bulk insert exception, key=&apos; || p_cursor_data_io&lt;br/&gt;         (l_coll_idx).product_instance_id || &apos;, exception=&apos; || SQL%BULK_EXCEPTIONS (i).ERROR_CODE );&lt;br/&gt;      END LOOP;&lt;br/&gt;   END;&lt;br/&gt;&lt;br/&gt;   pkg_logging.log_debug (p_process_rec_i, l_proc_name || &apos;, end&apos;);&lt;br/&gt;END insert_settop_box_inst;&lt;br/&gt;&lt;br/&gt;PROCEDURE insert_equip_instance_account&lt;br/&gt;   (&lt;br/&gt;      p_process_rec_i IN pkg_logging.t_process_rec,&lt;br/&gt;      p_cursor_data_io IN OUT NOCOPY t_cursor_data_tbl,&lt;br/&gt;      p_filter_i IN t_ptr_tbl&lt;br/&gt;   )&lt;br/&gt;IS&lt;br/&gt;   /****************************************************************************************************************&lt;br/&gt;   ||  SubProgram Name    : Procedure insert_equip_instance_account&lt;br/&gt;   ||  Estimated Run Time :&lt;br/&gt;   ||  Description        : The insert_equip_instance_account procedure will Insert insert_equip_instance_account rows&lt;br/&gt;   ||                       from staging data&lt;br/&gt;   ******************************************************************************************************************/&lt;br/&gt;   l_proc_name t_unit_name := &apos;INSERT_EQUIP_INSTANCE_ACCOUNT&apos;;&lt;br/&gt;   l_errors NUMBER;&lt;br/&gt;   l_coll_idx PLS_INTEGER;&lt;br/&gt;BEGIN&lt;br/&gt;   pkg_logging.log_debug (p_process_rec_i, l_proc_name || &apos;, cnt=&apos; || p_filter_i.COUNT () );&lt;br/&gt;&lt;br/&gt;   BEGIN&lt;br/&gt;      FORALL i IN VALUES OF p_filter_i SAVE EXCEPTIONS&lt;br/&gt;      INSERT&lt;br/&gt;      INTO&lt;br/&gt;         t_equip_instance_account a&lt;br/&gt;         (&lt;br/&gt;            a.account_id,&lt;br/&gt;            a.data_load_type_cd,&lt;br/&gt;            a.data_source_type_cd,&lt;br/&gt;            a.equip_prod_inst_id,&lt;br/&gt;            a.record_stat,&lt;br/&gt;            a.created_dttm,&lt;br/&gt;            a.created_by&lt;br/&gt;         )&lt;br/&gt;         VALUES&lt;br/&gt;         (&lt;br/&gt;            p_cursor_data_io (i).account_id,&lt;br/&gt;            &apos;NQL&apos;,&lt;br/&gt;            p_cursor_data_io (i).data_source_type_cd,&lt;br/&gt;            p_cursor_data_io (i).product_instance_id,&lt;br/&gt;            &apos;A&apos;,&lt;br/&gt;            SYSTIMESTAMP,&lt;br/&gt;            c_pkg_name&lt;br/&gt;         );&lt;br/&gt;   EXCEPTION&lt;br/&gt;   WHEN c_bulk_errors THEN&lt;br/&gt;      l_errors := SQL%BULK_EXCEPTIONS.COUNT;&lt;br/&gt;&lt;br/&gt;      FOR i IN 1 .. l_errors&lt;br/&gt;      LOOP&lt;br/&gt;         NULL;&lt;br/&gt;         l_coll_idx := p_filter_i (SQL%BULK_EXCEPTIONS (i).ERROR_INDEX);&lt;br/&gt;         p_cursor_data_io (l_coll_idx).record_load_cd := c_stg_error;&lt;br/&gt;         pkg_logging.log_exception (p_process_rec_i, l_proc_name || &apos;, bulk insert exception, key=&apos; || p_cursor_data_io&lt;br/&gt;         (l_coll_idx).account_num || &apos;:&apos; || p_cursor_data_io (l_coll_idx).equipment_esn_val || &apos;, exception=&apos; ||&lt;br/&gt;         SQL%BULK_EXCEPTIONS (i).ERROR_CODE );&lt;br/&gt;      END LOOP;&lt;br/&gt;   END;&lt;br/&gt;&lt;br/&gt;   pkg_logging.log_debug (p_process_rec_i, l_proc_name || &apos;, end&apos;);&lt;br/&gt;END insert_equip_instance_account;&lt;br/&gt;&lt;br/&gt;FUNCTION filter_equip_instance_account&lt;br/&gt;   (&lt;br/&gt;      p_process_rec_i IN pkg_logging.t_process_rec,&lt;br/&gt;      p_cursor_data_i IN t_cursor_data_tbl&lt;br/&gt;   )&lt;br/&gt;   RETURN t_ptr_tbl&lt;br/&gt;IS&lt;br/&gt;   /****************************************************************************************************************&lt;br/&gt;   ||  SubProgram Name    : Function filter_equip_instance_account&lt;br/&gt;   ||  Estimated Run Time :&lt;br/&gt;   ||  Description        : The filter_equip_instance_account function will return the filter equp with account&lt;br/&gt;   ||&lt;br/&gt;   ******************************************************************************************************************/&lt;br/&gt;   l_proc_name t_unit_name := &apos;FILTER_EQUIP_INSTANCE_ACCOUNT&apos;;&lt;br/&gt;   l_temp t_ptr_tbl;&lt;br/&gt;   l_idx PLS_INTEGER := 0;&lt;br/&gt;BEGIN&lt;br/&gt;   pkg_logging.log_debug (p_process_rec_i, l_proc_name);&lt;br/&gt;&lt;br/&gt;   FOR i IN 1 .. p_cursor_data_i.COUNT&lt;br/&gt;   LOOP&lt;br/&gt;      IF p_cursor_data_i&lt;br/&gt;         (&lt;br/&gt;            i&lt;br/&gt;         )&lt;br/&gt;         .account_id IS NOT NULL THEN&lt;br/&gt;         l_idx := l_idx + 1;&lt;br/&gt;         l_temp (l_idx) := i;&lt;br/&gt;      END IF;&lt;br/&gt;   END LOOP;&lt;br/&gt;&lt;br/&gt;   pkg_logging.log_debug (p_process_rec_i, l_proc_name || &apos;, end&apos;);&lt;br/&gt;   RETURN l_temp;&lt;br/&gt;END filter_equip_instance_account;&lt;br/&gt;&lt;br/&gt;FUNCTION filter_settop_box_instance&lt;br/&gt;   (&lt;br/&gt;      p_process_rec_i IN pkg_logging.t_process_rec,&lt;br/&gt;      p_cursor_data_i IN t_cursor_data_tbl&lt;br/&gt;   )&lt;br/&gt;   RETURN t_ptr_tbl&lt;br/&gt;IS&lt;br/&gt;   /****************************************************************************************************************&lt;br/&gt;   ||  SubProgram Name    : Function filter_settop_box_instance&lt;br/&gt;   ||  Estimated Run Time :&lt;br/&gt;   ||  Description        : The filter_settop_box_instance function will return the filter settop box&lt;br/&gt;   ||                       instance details&lt;br/&gt;   ******************************************************************************************************************/&lt;br/&gt;   l_proc_name t_unit_name := &apos;FILTER_SETTOP_BOX_INSTANCE&apos;;&lt;br/&gt;   l_temp t_ptr_tbl;&lt;br/&gt;   l_idx PLS_INTEGER := 0;&lt;br/&gt;BEGIN&lt;br/&gt;   pkg_logging.log_debug (p_process_rec_i, l_proc_name);&lt;br/&gt;&lt;br/&gt;   FOR i IN 1 .. p_cursor_data_i.COUNT&lt;br/&gt;   LOOP&lt;br/&gt;      IF (pkg_equip_utility.is_csg_settop_box(p_cursor_data_i(i).equip_prod_inst_type_cd)) THEN&lt;br/&gt;         l_idx := l_idx + 1;&lt;br/&gt;         l_temp (l_idx) := i;&lt;br/&gt;      END IF;&lt;br/&gt;   END LOOP;&lt;br/&gt;&lt;br/&gt;   pkg_logging.log_debug (p_process_rec_i, l_proc_name || &apos;, end&apos;);&lt;br/&gt;   RETURN l_temp;&lt;br/&gt;END filter_settop_box_instance;&lt;br/&gt;&lt;br/&gt;PROCEDURE update_staging&lt;br/&gt;   (&lt;br/&gt;      p_process_rec_i IN pkg_logging.t_process_rec,&lt;br/&gt;      p_cursor_data_i IN t_cursor_data_tbl&lt;br/&gt;   )&lt;br/&gt;IS&lt;br/&gt;   /****************************************************************************************************************&lt;br/&gt;   ||  SubProgram Name    : Procedure load_initial_data&lt;br/&gt;   ||  Estimated Run Time :&lt;br/&gt;   ||  Description        : The update_staging procedure will update the stg.vnt_nql_hist.&lt;br/&gt;   ******************************************************************************************************************/&lt;br/&gt;   l_proc_name t_unit_name := &apos;UPDATE_STAGING&apos;;&lt;br/&gt;BEGIN&lt;br/&gt;   pkg_logging.log_debug (p_process_rec_i, l_proc_name);&lt;br/&gt;   FORALL i IN 1 .. p_cursor_data_i.COUNT&lt;br/&gt;   UPDATE&lt;br/&gt;      stg.vnt_nql_hist_il s&lt;br/&gt;   SET&lt;br/&gt;      s.record_load_cd = NVL (p_cursor_data_i (i).record_load_cd, c_stg_processed),&lt;br/&gt;      s.record_dttm = SYSTIMESTAMP&lt;br/&gt;   WHERE&lt;br/&gt;      ROWID = p_cursor_data_i (i).ID;&lt;br/&gt;   pkg_logging.log_debug (p_process_rec_i, l_proc_name || &apos;, end&apos;);&lt;br/&gt;END update_staging;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;-- Apply the rules to t_settop_box_instance&lt;br/&gt;PROCEDURE finalize(&lt;br/&gt;   p_audit_user_i IN VARCHAR2)&lt;br/&gt;IS&lt;br/&gt;   l_proc_name t_unit_name := &apos;FINALIZE&apos;;&lt;br/&gt;   l_process_name t_process_log.process_name%TYPE := c_pkg_name;&lt;br/&gt;   l_process_rec pkg_logging.t_process_rec;&lt;br/&gt;&lt;br/&gt;   CURSOR cur_sb&lt;br/&gt;   IS&lt;br/&gt;      SELECT /*+ parallel(sb,8) */&lt;br/&gt;         sb.rowid as rid,&lt;br/&gt;         sb.settop_box_instance_id,&lt;br/&gt;         sb.serial_num,&lt;br/&gt;         pkg_equip_utility.cnvrt_eqmt_addr(ec01.equip_mac_address_id) AS mac_address_01,&lt;br/&gt;         pkg_equip_utility.cnvrt_eqmt_addr(ec01.equip_sec_mac_address_id) AS sec_mac_address_01,&lt;br/&gt;         pkg_equip_utility.cnvrt_eqmt_addr(ecem.equip_mac_address_id) AS mac_address_em,&lt;br/&gt;         pkg_equip_utility.cnvrt_eqmt_addr(ecem.equip_sec_mac_address_id) AS sec_mac_address_em,&lt;br/&gt;         pkg_equip_utility.cnvrt_eqmt_addr(ecvh.equip_mac_address_id) AS mac_address_vh,&lt;br/&gt;         pkg_equip_utility.cnvrt_eqmt_addr(ecvh.equip_sec_mac_address_id) AS sec_mac_address_vh&lt;br/&gt;      FROM&lt;br/&gt;         t_settop_box_instance sb&lt;br/&gt;      LEFT OUTER JOIN t_equip_component ec01&lt;br/&gt;      ON&lt;br/&gt;         ec01.equip_prod_inst_id=sb.settop_box_instance_id&lt;br/&gt;         AND ec01.equip_component_type_cd = &apos;01&apos;&lt;br/&gt;      LEFT OUTER JOIN t_equip_component ecem&lt;br/&gt;      ON&lt;br/&gt;         ecem.equip_prod_inst_id=sb.settop_box_instance_id&lt;br/&gt;         AND ecem.equip_component_type_cd = &apos;EM&apos;&lt;br/&gt;      LEFT OUTER JOIN t_equip_component ecvh&lt;br/&gt;      ON&lt;br/&gt;         ecvh.equip_prod_inst_id=sb.settop_box_instance_id&lt;br/&gt;         AND ecvh.equip_component_type_cd = &apos;VH&apos;&lt;br/&gt;      ;&lt;br/&gt;&lt;br/&gt;   TYPE t_cursor_data_tbl&lt;br/&gt;   IS&lt;br/&gt;      TABLE OF cur_sb%ROWTYPE INDEX BY PLS_INTEGER;&lt;br/&gt;   l_cursor_data t_cursor_data_tbl;&lt;br/&gt;&lt;br/&gt;BEGIN&lt;br/&gt;   l_process_rec.process_name := l_process_name;&lt;br/&gt;   pkg_logging.begin_process (l_process_rec, &apos;p_audit_user_i=&apos; || p_audit_user_i );&lt;br/&gt;&lt;br/&gt;   OPEN cur_sb;&lt;br/&gt;&lt;br/&gt;   LOOP&lt;br/&gt;      FETCH cur_sb BULK COLLECT INTO l_cursor_data LIMIT 5000;&lt;br/&gt;&lt;br/&gt;      IF (l_cursor_data.COUNT () &gt; 0) THEN&lt;br/&gt;&lt;br/&gt;         FOR i IN 1 .. l_cursor_data.COUNT&lt;br/&gt;         LOOP&lt;br/&gt;            UPDATE T_SETTOP_BOX_INSTANCE&lt;br/&gt;            SET estb_mac_address=nvl(l_cursor_data(i).mac_address_01,nvl(l_cursor_data(i).sec_mac_address_vh,l_cursor_data(i).mac_address_vh)),&lt;br/&gt;               ecm_mac_address=decode(l_cursor_data(i).mac_address_01,NULL,l_cursor_data(i).mac_address_em,NULL)&lt;br/&gt;            WHERE rowid=l_cursor_data(i).rid&lt;br/&gt;            AND settop_box_instance_id=l_cursor_data(i).settop_box_instance_id;&lt;br/&gt;         END LOOP;&lt;br/&gt;         COMMIT;&lt;br/&gt;&lt;br/&gt;      END IF;&lt;br/&gt;      COMMIT;&lt;br/&gt;&lt;br/&gt;      EXIT&lt;br/&gt;   WHEN l_cursor_data.COUNT() &lt; 1000;&lt;br/&gt;   END LOOP;&lt;br/&gt;&lt;br/&gt;   CLOSE cur_sb;&lt;br/&gt;&lt;br/&gt;   pkg_logging.end_process (l_process_rec);&lt;br/&gt;EXCEPTION&lt;br/&gt;WHEN OTHERS THEN&lt;br/&gt;   IF (cur_sb%ISOPEN) THEN&lt;br/&gt;      CLOSE cur_sb;&lt;br/&gt;   END IF;&lt;br/&gt;&lt;br/&gt;   ROLLBACK;&lt;br/&gt;   pkg_logging.end_process (l_process_rec, &apos;ERROR WHILE PROCESSING&apos;);&lt;br/&gt;   pkg_logging.log_exception (l_process_rec, DBMS_UTILITY.format_error_stack () );&lt;br/&gt;   RAISE;&lt;br/&gt;END finalize;&lt;br/&gt;&lt;br/&gt;END pkg_vnt_load_nql_hist;</source>
</body>
</PackageOracle>
<?xml version = '1.0' encoding = 'UTF-8'?>
<PackageOracle class="oracle.dbtools.crest.model.design.storage.oracle.PackageOracle" name="PKG_VNT_PROCESS_NRT_ACCT" directorySegmentName="seg_6" id="6CB0F810-E90B-6D59-327A-408C329D1C95">
<sourceConnName>SOLO_Prod</sourceConnName>
<sourceObjSchema>CHTR</sourceObjSchema>
<sourceObjName>PKG_VNT_PROCESS_NRT_ACCT</sourceObjName>
<createdBy>jandrews1</createdBy>
<createdTime>2015-08-11 13:18:24 UTC</createdTime>
<ownerDesignName>SOLO_DECEMBER_RE</ownerDesignName>
<owner>5AF9E3FC-7A76-C437-3E83-BF29D7EA2FC7</owner>
<source>CREATE OR REPLACE PACKAGE      CHTR.PKG_VNT_PROCESS_NRT_ACCT&lt;br/&gt;/****************************************************************************************************************&lt;br/&gt;||  Program Name    : pkg_vnt_process_nrt_acct&lt;br/&gt;||  Created By      : Knoll&lt;br/&gt;||  Created Date    : 04-Aug-2014&lt;br/&gt;||  Subject Area    : Account&lt;br/&gt;||  Description     : The package  is for wrapping procedures and functions&lt;br/&gt;||                    that will be used for loading the inserts/Updates from  the Vantage table NRT_ACCT into&lt;br/&gt;||                     SOLODB&lt;br/&gt;||  Change log:&lt;br/&gt;||&lt;br/&gt;||    Changed By      Changed On      Change Description&lt;br/&gt;||  -------------------------------------------------------------------------------------------------------------&lt;br/&gt;||     Cognizant      10-Nov-2014     Standardization Changes&lt;br/&gt;******************************************************************************************************************/&lt;br/&gt;IS&lt;br/&gt;PROCEDURE process(&lt;br/&gt;         p_audit_user_i IN VARCHAR2);&lt;br/&gt;END pkg_vnt_process_nrt_acct;</source>
<body class="oracle.dbtools.crest.model.design.storage.oracle.PackageBodyOracle" name="PKG_VNT_PROCESS_NRT_ACCT" id="6CB0F810-E90B-6D59-327A-408C329D1C95">
<sourceConnName>SOLO_Prod</sourceConnName>
<sourceObjSchema>CHTR</sourceObjSchema>
<sourceObjName>PKG_VNT_PROCESS_NRT_ACCT</sourceObjName>
<createdBy>jandrews1</createdBy>
<createdTime>2015-08-11 13:18:26 UTC</createdTime>
<ownerDesignName>SOLO_DECEMBER_RE</ownerDesignName>
<owner>5AF9E3FC-7A76-C437-3E83-BF29D7EA2FC7</owner>
<source>CREATE OR REPLACE PACKAGE BODY      CHTR.PKG_VNT_PROCESS_NRT_ACCT&lt;br/&gt;IS&lt;br/&gt;/****************************************************************************************************************&lt;br/&gt;||  Program Name    : pkg_vnt_process_nrt_acct&lt;br/&gt;||  Created By      : Knoll&lt;br/&gt;||  Subject Area    : Account&lt;br/&gt;||  Description     : The package  is for wrapping procedures and functions that will be used for loading&lt;br/&gt;||                    the inserts/Updates from  the Vantage table NRT_ACCT into SOLODB&lt;br/&gt;||  Change log:&lt;br/&gt;||&lt;br/&gt;||    Changed By      Changed On      Change Description&lt;br/&gt;||  -------------------------------------------------------------------------------------------------------------&lt;br/&gt;||     Cognizant      10-Nov-2014     Standardization Changes&lt;br/&gt;||     Cognizant      31-Mar-2015     Decode removal for nacc.vip_flg_nacc&lt;br/&gt;||     Cognizant      07-Apr-2015     Code changes to remove the descrepanies between NRT/RRT , Initial Load and Reconciliation&lt;br/&gt;||     Cognizant      10-Apr-2015     Trim included for character column in cursor query.&lt;br/&gt;||     Binoy          24-Jun-2015     Populate the data into the column BILLING_STATION_ID.T_ACCOUNT&lt;br/&gt;||                                    as part of XDW change.&lt;br/&gt;******************************************************************************************************************/&lt;br/&gt;   SUBTYPE t_unit_name IS VARCHAR2 (30);&lt;br/&gt;&lt;br/&gt;   SUBTYPE t_userid IS VARCHAR2 (100 BYTE);&lt;br/&gt;&lt;br/&gt;   c_pkg_name   CONSTANT t_unit_name := &apos;PKG_VNT_PROCESS_NRT_ACCT&apos;;&lt;br/&gt;   c_bulk_errors         EXCEPTION;&lt;br/&gt;   PRAGMA EXCEPTION_INIT (c_bulk_errors, -24381);&lt;br/&gt;&lt;br/&gt;   CURSOR cur_stg_nrt_acct&lt;br/&gt;   IS&lt;br/&gt;      SELECT   nacc.ROWID AS ID, nacc.record_load_cd,&lt;br/&gt;               nacc.sub_acct_no_nacc AS account_num,&lt;br/&gt;               TRIM (nacc.hse_key_nacc) AS house_key, a.account_id,&lt;br/&gt;               xref.address_id service_address_id,&lt;br/&gt;               TRIM&lt;br/&gt;                  (CASE&lt;br/&gt;                      WHEN INSTR (nacc.res_name_nacc, &apos;*&apos;) &gt; 2&lt;br/&gt;                         THEN SUBSTR (nacc.res_name_nacc,&lt;br/&gt;                                      1,&lt;br/&gt;                                      INSTR (nacc.res_name_nacc, &apos;*&apos;) - 2&lt;br/&gt;                                     )&lt;br/&gt;                      ELSE nacc.res_name_nacc&lt;br/&gt;                   END&lt;br/&gt;                  ) AS account_nm,&lt;br/&gt;               DECODE (nacc.cust_typ_nacc,&lt;br/&gt;                       &apos;COM&apos;, &apos;BUSN&apos;,&lt;br/&gt;                       &apos;RES&apos;, &apos;INDIV&apos;,&lt;br/&gt;                       NULL&lt;br/&gt;                      ) AS account_type_cd,&lt;br/&gt;               TRIM (nacc.vip_flg_nacc) AS account_qualifier_cd,&lt;br/&gt;               a.account_nm AS cur_account_nm,&lt;br/&gt;               TRIM (a.account_type_cd) AS cur_account_type_cd,&lt;br/&gt;               TRIM (a.account_qualifier_cd) AS cur_account_qualifier_cd,&lt;br/&gt;               TRIM (nacc.hse_key_nacc) AS hse_key,&lt;br/&gt;               TRIM (nacc.addr1_nacc) AS address_line_1_txt,&lt;br/&gt;               TRIM (nacc.res_addr_2_nacc) AS address_line_2_txt,&lt;br/&gt;               TRIM (nacc.res_city_nacc) AS city_nm,&lt;br/&gt;               TRIM (nacc.res_state_nacc) AS territory_cd,&lt;br/&gt;               &apos;USA&apos; AS country_cd,&lt;br/&gt;               TRIM (nacc.res_postal_cde_nacc) AS postal_code_txt,&lt;br/&gt;               TRIM (nacc.hse_key_nacc) AS source_system_address_id,&lt;br/&gt;               CASE&lt;br/&gt;                  WHEN nacc.sys_nacc = 8313&lt;br/&gt;                     THEN &apos;BRS&apos;&lt;br/&gt;                  ELSE &apos;VNT&apos;&lt;br/&gt;               END AS data_source_type_cd,&lt;br/&gt;               bs.billing_station_id&lt;br/&gt;          FROM stg.vnt_nrt_acct nacc LEFT OUTER JOIN t_account_vantage_xref x&lt;br/&gt;               ON x.sub_acct_num = nacc.sub_acct_no_nacc&lt;br/&gt;             AND x.record_stat = pkg_utility.c_record_active&lt;br/&gt;               LEFT OUTER JOIN t_account a&lt;br/&gt;               ON a.account_id = x.account_id&lt;br/&gt;             AND a.record_stat = pkg_utility.c_record_active&lt;br/&gt;               LEFT OUTER JOIN t_service_address_vantage_xref xref&lt;br/&gt;               ON xref.hs_key = nacc.hse_key_nacc&lt;br/&gt;             AND xref.record_stat = pkg_utility.c_record_active&lt;br/&gt;               LEFT OUTER JOIN t_billing_station bs&lt;br/&gt;               ON bs.billing_station_level_1_cd = nacc.sys_nacc&lt;br/&gt;             AND bs.billing_station_level_2_cd = nacc.prin_nacc&lt;br/&gt;         WHERE nacc.record_load_cd IS NULL&lt;br/&gt;      ORDER BY nacc.pull_dte_nacc,&lt;br/&gt;               DECODE (nacc.pull_tme_slot_nacc,&lt;br/&gt;                       1, pkg_utility.l_final_slot,&lt;br/&gt;                       nacc.pull_tme_slot_nacc&lt;br/&gt;                      ),&lt;br/&gt;               nacc.ls_chg_dte_nacc;&lt;br/&gt;&lt;br/&gt;   TYPE t_cursor_data_tbl IS TABLE OF cur_stg_nrt_acct%ROWTYPE&lt;br/&gt;      INDEX BY PLS_INTEGER;&lt;br/&gt;&lt;br/&gt;   -- Forward declarations&lt;br/&gt;   PROCEDURE process_row (&lt;br/&gt;      p_process_rec_i   IN              pkg_logging.t_process_rec,&lt;br/&gt;      p_audit_user_i    IN              t_userid,&lt;br/&gt;      p_cursor_row_i    IN OUT NOCOPY   cur_stg_nrt_acct%ROWTYPE&lt;br/&gt;   );&lt;br/&gt;&lt;br/&gt;   PROCEDURE update_staging (&lt;br/&gt;      p_process_rec_i   IN              pkg_logging.t_process_rec,&lt;br/&gt;      p_cursor_row_i    IN OUT NOCOPY   cur_stg_nrt_acct%ROWTYPE&lt;br/&gt;   );&lt;br/&gt;&lt;br/&gt;   FUNCTION get_account (&lt;br/&gt;      p_process_rec_i   IN       pkg_logging.t_process_rec,&lt;br/&gt;      p_source_key      IN       t_account_vantage_xref.sub_acct_num%TYPE,&lt;br/&gt;      p_account_id      OUT      t_account.account_id%TYPE&lt;br/&gt;   )&lt;br/&gt;      RETURN BOOLEAN;&lt;br/&gt;&lt;br/&gt;   PROCEDURE process (&lt;br/&gt;                      /*************************************************************************************************************&lt;br/&gt;                      ||  SubProgram Name    : Procedure process&lt;br/&gt;                      ||  Estimated Run Time :&lt;br/&gt;                      ||  Description        : The procedure process opens the main cursor and calls the procedure process_row for&lt;br/&gt;                      ||                       each row. The procedure update_staging is used to update the process status in the&lt;br/&gt;                      ||                       staging table.&lt;br/&gt;                      *************************************************************************************************************/&lt;br/&gt;                      p_audit_user_i IN VARCHAR2)&lt;br/&gt;   IS&lt;br/&gt;      l_proc_name            t_unit_name                       := &apos;PROCESS&apos;;&lt;br/&gt;      l_process_name         t_process_log.process_name%TYPE   := c_pkg_name;&lt;br/&gt;      l_process_rec          pkg_logging.t_process_rec;&lt;br/&gt;      l_cursor_data          t_cursor_data_tbl;&lt;br/&gt;      l_audit_user           t_userid;&lt;br/&gt;      l_process_record_cnt   NUMBER                            := 0;&lt;br/&gt;      l_error_record_cnt     NUMBER                            := 0;&lt;br/&gt;   BEGIN&lt;br/&gt;      l_audit_user := NVL (p_audit_user_i, c_pkg_name);&lt;br/&gt;      l_process_rec.process_name := l_process_name;&lt;br/&gt;      pkg_logging.begin_process (l_process_rec,&lt;br/&gt;                                 &apos;p_audit_user_i=&apos; || l_audit_user&lt;br/&gt;                                );&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos;&lt;br/&gt;                             || pkg_utility.c_proc_start_text&lt;br/&gt;                            );&lt;br/&gt;&lt;br/&gt;      IF (cur_stg_nrt_acct%ISOPEN)&lt;br/&gt;      THEN&lt;br/&gt;         CLOSE cur_stg_nrt_acct;&lt;br/&gt;      END IF;&lt;br/&gt;&lt;br/&gt;      OPEN cur_stg_nrt_acct;&lt;br/&gt;&lt;br/&gt;      LOOP&lt;br/&gt;         FETCH cur_stg_nrt_acct&lt;br/&gt;         BULK COLLECT INTO l_cursor_data LIMIT pkg_utility.c_rt_batchsize;&lt;br/&gt;&lt;br/&gt;         IF (l_cursor_data.COUNT () &gt; 0)&lt;br/&gt;         THEN&lt;br/&gt;            -- process the updates&lt;br/&gt;            FOR i IN 1 .. l_cursor_data.COUNT&lt;br/&gt;            LOOP&lt;br/&gt;               BEGIN&lt;br/&gt;                  process_row (l_process_rec, l_audit_user,&lt;br/&gt;                               l_cursor_data (i));&lt;br/&gt;                  update_staging (l_process_rec, l_cursor_data (i));&lt;br/&gt;                  COMMIT;&lt;br/&gt;               EXCEPTION&lt;br/&gt;                  WHEN OTHERS&lt;br/&gt;                  THEN&lt;br/&gt;                     ROLLBACK;&lt;br/&gt;                     l_cursor_data (i).record_load_cd :=&lt;br/&gt;                                                      pkg_utility.c_stg_error;&lt;br/&gt;                     pkg_logging.log_exception&lt;br/&gt;                                          (l_process_rec,&lt;br/&gt;                                              l_proc_name&lt;br/&gt;                                           || &apos;, ACCOUNT_ID=&apos;&lt;br/&gt;                                           || l_cursor_data (i).account_id&lt;br/&gt;                                           || &apos; exception=&apos;&lt;br/&gt;                                           || DBMS_UTILITY.format_error_stack&lt;br/&gt;                                                                           ()&lt;br/&gt;                                          );&lt;br/&gt;               END;&lt;br/&gt;&lt;br/&gt;               --Capturing the Processed/error record count&lt;br/&gt;               SELECT   DECODE (l_cursor_data (i).record_load_cd,&lt;br/&gt;                                NULL, 1,&lt;br/&gt;                                pkg_utility.c_stg_processed, 1,&lt;br/&gt;                                0&lt;br/&gt;                               )&lt;br/&gt;                      + l_process_record_cnt,&lt;br/&gt;                        DECODE (l_cursor_data (i).record_load_cd,&lt;br/&gt;                                pkg_utility.c_stg_error, 1,&lt;br/&gt;                                0&lt;br/&gt;                               )&lt;br/&gt;                      + l_error_record_cnt&lt;br/&gt;                 INTO l_process_record_cnt,&lt;br/&gt;                      l_error_record_cnt&lt;br/&gt;                 FROM DUAL;&lt;br/&gt;            END LOOP;&lt;br/&gt;         END IF;&lt;br/&gt;&lt;br/&gt;         EXIT WHEN l_cursor_data.COUNT () &lt; pkg_utility.c_rt_batchsize;&lt;br/&gt;      END LOOP;&lt;br/&gt;&lt;br/&gt;      CLOSE cur_stg_nrt_acct;&lt;br/&gt;&lt;br/&gt;      --Making entry to the Process Child table against Total Processed Record Count&lt;br/&gt;      pkg_logging.process_log_detail_populate&lt;br/&gt;                          (p_process_rec_i        =&gt; l_process_rec,&lt;br/&gt;                           p_audit_bucket_i       =&gt; pkg_utility.c_prcssed_rec_text,&lt;br/&gt;                           p_audit_value_i        =&gt; l_process_record_cnt,&lt;br/&gt;                           p_process_id_i         =&gt; l_process_rec.process_id,&lt;br/&gt;                           p_in_audit_user_i      =&gt; p_audit_user_i&lt;br/&gt;                          );&lt;br/&gt;      --Making entry to the Process Child table against Total Error Record Count&lt;br/&gt;      pkg_logging.process_log_detail_populate&lt;br/&gt;                            (p_process_rec_i        =&gt; l_process_rec,&lt;br/&gt;                             p_audit_bucket_i       =&gt; pkg_utility.c_error_rec_text,&lt;br/&gt;                             p_audit_value_i        =&gt; l_error_record_cnt,&lt;br/&gt;                             p_process_id_i         =&gt; l_process_rec.process_id,&lt;br/&gt;                             p_in_audit_user_i      =&gt; p_audit_user_i&lt;br/&gt;                            );&lt;br/&gt;      pkg_logging.end_process (l_process_rec, pkg_utility.c_process_success);&lt;br/&gt;      pkg_logging.log_debug (l_process_rec,&lt;br/&gt;                             l_proc_name || &apos; &apos; || pkg_utility.c_proc_end_text&lt;br/&gt;                            );&lt;br/&gt;   --Exception Handling&lt;br/&gt;   EXCEPTION&lt;br/&gt;      WHEN OTHERS&lt;br/&gt;      THEN&lt;br/&gt;         ROLLBACK;&lt;br/&gt;         pkg_logging.log_exception (l_process_rec,&lt;br/&gt;                                       l_proc_name&lt;br/&gt;                                    || &apos;, exception=&apos;&lt;br/&gt;                                    || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                                   );&lt;br/&gt;         pkg_logging.end_process (l_process_rec, pkg_utility.c_process_error);&lt;br/&gt;&lt;br/&gt;         IF (cur_stg_nrt_acct%ISOPEN)&lt;br/&gt;         THEN&lt;br/&gt;            CLOSE cur_stg_nrt_acct;&lt;br/&gt;         END IF;&lt;br/&gt;&lt;br/&gt;         RAISE;&lt;br/&gt;   END process;&lt;br/&gt;&lt;br/&gt;   PROCEDURE process_row (&lt;br/&gt;      /****************************************************************************************************************&lt;br/&gt;      ||  SubProgram Name    : Procedure process_row&lt;br/&gt;      ||  Estimated Run Time :&lt;br/&gt;      ||  Description        : The procedure process_row takes the cursor row as input  and check if the account _id&lt;br/&gt;      ||                       exsists using function get_account and the id column account_num in the cursor.&lt;br/&gt;      ||                       If it does not, then records are added to T_ACCOUNT and the XREF Tables using the&lt;br/&gt;      ||                       packages da_account.ADD,da_account_vantage_xref.ADD. If, account exists, only the table&lt;br/&gt;      ||                       T_ACCOUNT is updated using Update statement.&lt;br/&gt;      *****************************************************************************************************************&lt;br/&gt;      */&lt;br/&gt;      p_process_rec_i   IN              pkg_logging.t_process_rec,&lt;br/&gt;      p_audit_user_i    IN              t_userid,&lt;br/&gt;      p_cursor_row_i    IN OUT NOCOPY   cur_stg_nrt_acct%ROWTYPE&lt;br/&gt;   )&lt;br/&gt;   IS&lt;br/&gt;      l_account_id       NUMBER;&lt;br/&gt;      l_address_id       NUMBER;&lt;br/&gt;      l_update_account   BOOLEAN             := FALSE;&lt;br/&gt;      l_account          t_account%ROWTYPE;&lt;br/&gt;      l_proc_name        t_unit_name         := &apos;PROCESS_ROW&apos;;&lt;br/&gt;   BEGIN&lt;br/&gt;      pkg_logging.log_debug (p_process_rec_i,&lt;br/&gt;                                l_proc_name&lt;br/&gt;                             || &apos;, &apos;&lt;br/&gt;                             || pkg_utility.c_proc_start_text&lt;br/&gt;                             || &apos; , account_num=&apos;&lt;br/&gt;                             || p_cursor_row_i.account_num&lt;br/&gt;                            );&lt;br/&gt;      l_account_id := NULL;&lt;br/&gt;&lt;br/&gt;      IF (    NOT get_account (p_process_rec_i      =&gt; p_process_rec_i,&lt;br/&gt;                               p_source_key         =&gt; p_cursor_row_i.account_num,&lt;br/&gt;                               p_account_id         =&gt; l_account_id&lt;br/&gt;                              )&lt;br/&gt;          AND (p_cursor_row_i.account_id IS NULL)&lt;br/&gt;         )&lt;br/&gt;      THEN&lt;br/&gt;         l_account_id :=&lt;br/&gt;            da_account.ADD&lt;br/&gt;                (process_rec                     =&gt; p_process_rec_i,&lt;br/&gt;                 data_source_type_cd             =&gt; p_cursor_row_i.data_source_type_cd,&lt;br/&gt;                 account_num                     =&gt; p_cursor_row_i.account_num,&lt;br/&gt;                 account_nm                      =&gt; p_cursor_row_i.account_nm,&lt;br/&gt;                 account_open_dt                 =&gt; NULL,&lt;br/&gt;                 account_close_dt                =&gt; NULL,&lt;br/&gt;                 account_type_cd                 =&gt; p_cursor_row_i.account_type_cd,&lt;br/&gt;                 account_purpose_subtype_cd      =&gt; &apos;BLG&apos;,&lt;br/&gt;                 subaccount_ind                  =&gt; 0,&lt;br/&gt;                 account_qualifier_cd            =&gt; p_cursor_row_i.account_qualifier_cd,&lt;br/&gt;                 billing_station_id              =&gt; p_cursor_row_i.billing_station_id,&lt;br/&gt;                 audit_user                      =&gt; p_audit_user_i,&lt;br/&gt;                 dunning_group_cd                =&gt; NULL&lt;br/&gt;                );&lt;br/&gt;         da_account_vantage_xref.ADD&lt;br/&gt;                                  (process_rec       =&gt; p_process_rec_i,&lt;br/&gt;                                   sub_acct_num      =&gt; p_cursor_row_i.account_num,&lt;br/&gt;                                   account_id        =&gt; l_account_id,&lt;br/&gt;                                   audit_user        =&gt; p_audit_user_i&lt;br/&gt;                                  );&lt;br/&gt;      ELSE&lt;br/&gt;         UPDATE t_account t&lt;br/&gt;            SET account_nm = p_cursor_row_i.account_nm,&lt;br/&gt;                account_type_cd =&lt;br/&gt;                         NVL (p_cursor_row_i.account_type_cd, account_type_cd),&lt;br/&gt;                account_qualifier_cd = p_cursor_row_i.account_qualifier_cd,&lt;br/&gt;                modified_dttm = SYSTIMESTAMP,&lt;br/&gt;                modified_by = p_audit_user_i&lt;br/&gt;          WHERE account_id = l_account_id;&lt;br/&gt;      END IF;&lt;br/&gt;&lt;br/&gt;      p_cursor_row_i.record_load_cd := pkg_utility.c_stg_processed;&lt;br/&gt;      pkg_logging.log_debug (p_process_rec_i,&lt;br/&gt;                             l_proc_name || &apos; &apos; || pkg_utility.c_proc_end_text&lt;br/&gt;                            );&lt;br/&gt;   EXCEPTION&lt;br/&gt;      WHEN OTHERS&lt;br/&gt;      THEN&lt;br/&gt;         ROLLBACK;&lt;br/&gt;         p_cursor_row_i.record_load_cd := pkg_utility.c_stg_error;&lt;br/&gt;         pkg_logging.log_exception (p_process_rec_i,&lt;br/&gt;                                       l_proc_name&lt;br/&gt;                                    || &apos;, ACCOUNT_ID = &apos;&lt;br/&gt;                                    || p_cursor_row_i.account_id&lt;br/&gt;                                    || &apos; , ACCOUNT_NUM = &apos;&lt;br/&gt;                                    || p_cursor_row_i.account_num&lt;br/&gt;                                    || &apos;, exception=&apos;&lt;br/&gt;                                    || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                                   );&lt;br/&gt;   END process_row;&lt;br/&gt;&lt;br/&gt;   FUNCTION get_account (&lt;br/&gt;      /****************************************************************************************************************&lt;br/&gt;      ||  SubProgram Name    : Procedure get_account&lt;br/&gt;      ||  Estimated Run Time :&lt;br/&gt;      ||  Description        : The procedure get_account takes the sub_acct_num as input and return  account_id if&lt;br/&gt;      ||                       the record exists in a join of T_ACCOUNT and the XREF table.&lt;br/&gt;      *****************************************************************************************************************&lt;br/&gt;      */&lt;br/&gt;      p_process_rec_i   IN       pkg_logging.t_process_rec,&lt;br/&gt;      p_source_key      IN       t_account_vantage_xref.sub_acct_num%TYPE,&lt;br/&gt;      p_account_id      OUT      t_account.account_id%TYPE&lt;br/&gt;   )&lt;br/&gt;      RETURN BOOLEAN&lt;br/&gt;   IS&lt;br/&gt;      l_proc_name   t_unit_name := &apos;GET_ACCOUNT&apos;;&lt;br/&gt;   BEGIN&lt;br/&gt;      pkg_logging.log_debug (p_process_rec_i,&lt;br/&gt;                                l_proc_name&lt;br/&gt;                             || &apos;, &apos;&lt;br/&gt;                             || pkg_utility.c_proc_start_text&lt;br/&gt;                             || &apos; , account_num=&apos;&lt;br/&gt;                             || p_source_key&lt;br/&gt;                            );&lt;br/&gt;&lt;br/&gt;      SELECT a.account_id&lt;br/&gt;        INTO p_account_id&lt;br/&gt;        FROM t_account_vantage_xref x INNER JOIN t_account a&lt;br/&gt;             ON a.account_id = x.account_id&lt;br/&gt;           AND a.record_stat = pkg_utility.c_record_active&lt;br/&gt;       WHERE x.sub_acct_num = p_source_key&lt;br/&gt;         AND x.record_stat = pkg_utility.c_record_active;&lt;br/&gt;&lt;br/&gt;      pkg_logging.log_debug (p_process_rec_i,&lt;br/&gt;                             l_proc_name || &apos; &apos; || pkg_utility.c_proc_end_text&lt;br/&gt;                            );&lt;br/&gt;      RETURN TRUE;&lt;br/&gt;   EXCEPTION&lt;br/&gt;      WHEN NO_DATA_FOUND&lt;br/&gt;      THEN&lt;br/&gt;         RETURN FALSE;&lt;br/&gt;   END get_account;&lt;br/&gt;&lt;br/&gt;   PROCEDURE update_staging (&lt;br/&gt;      /****************************************************************************************************************&lt;br/&gt;      ||  SubProgram Name    : Procedure get_account&lt;br/&gt;      ||  Estimated Run Time :&lt;br/&gt;      ||  Description        : The procedure update_staging takes the cursor row as input and updates the staging&lt;br/&gt;      ||                       table with record_load_cd= &apos;P&apos;&lt;br/&gt;      *****************************************************************************************************************&lt;br/&gt;      */&lt;br/&gt;      p_process_rec_i   IN              pkg_logging.t_process_rec,&lt;br/&gt;      p_cursor_row_i    IN OUT NOCOPY   cur_stg_nrt_acct%ROWTYPE&lt;br/&gt;   )&lt;br/&gt;   IS&lt;br/&gt;      l_proc_name   t_unit_name := &apos;UPDATE_STAGING&apos;;&lt;br/&gt;   BEGIN&lt;br/&gt;      pkg_logging.log_debug (p_process_rec_i,&lt;br/&gt;                             l_proc_name || &apos; &apos;&lt;br/&gt;                             || pkg_utility.c_proc_start_text&lt;br/&gt;                            );&lt;br/&gt;&lt;br/&gt;      BEGIN&lt;br/&gt;         UPDATE stg.vnt_nrt_acct s&lt;br/&gt;            SET s.record_load_cd =&lt;br/&gt;                   NVL (p_cursor_row_i.record_load_cd,&lt;br/&gt;                        pkg_utility.c_stg_processed&lt;br/&gt;                       ),&lt;br/&gt;                s.record_dttm = SYSTIMESTAMP&lt;br/&gt;          WHERE ROWID = p_cursor_row_i.ID;&lt;br/&gt;      EXCEPTION&lt;br/&gt;         WHEN OTHERS&lt;br/&gt;         THEN&lt;br/&gt;            ROLLBACK;&lt;br/&gt;            p_cursor_row_i.record_load_cd := pkg_utility.c_stg_error;&lt;br/&gt;            pkg_logging.log_exception (p_process_rec_i,&lt;br/&gt;                                          l_proc_name&lt;br/&gt;                                       || &apos;, ACCOUNT_ID=&apos;&lt;br/&gt;                                       || p_cursor_row_i.account_id&lt;br/&gt;                                       || &apos;, ROWID  = &apos;&lt;br/&gt;                                       || p_cursor_row_i.ID&lt;br/&gt;                                       || &apos;, EXCEPTION = &apos;&lt;br/&gt;                                       || DBMS_UTILITY.format_error_stack ()&lt;br/&gt;                                      );&lt;br/&gt;      END;&lt;br/&gt;&lt;br/&gt;      pkg_logging.log_debug (p_process_rec_i,&lt;br/&gt;                             l_proc_name || &apos; &apos; || pkg_utility.c_proc_end_text&lt;br/&gt;                            );&lt;br/&gt;   END update_staging;&lt;br/&gt;END pkg_vnt_process_nrt_acct;</source>
</body>
</PackageOracle>